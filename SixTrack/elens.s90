+dk elens

module elens
  use parpro
  use floatPrecision
  implicit none
  
  ! M. Fitterer (FNAL), A. Mereghtti (CERN, BE-ABP-HSS)
  ! last modified: 28-02-2018
  ! Common block for electron lens definition

  ! size of table with elens data
  integer, parameter     :: nelens=100
  ! last elens read
  integer, save          :: melens
  
  ! index of elens:
  integer, save          :: ielens(nele)
  
  ! variables to save elens parameters for tracking etc.
  integer, save          :: elens_type(nelens)        ! integer for elens type
                                                      ! 0 : Un-initialized.
                                                      ! 1 : (Hollow annular) elens, uniform electron profile
                                                      ! 2 : (Hollow annular) elens, Gaussian electron profile
  real(kind=fPrec), save :: elens_theta_r2(nelens)    ! kick strength at R2 [mrad]
  real(kind=fPrec), save :: elens_r2(nelens)          ! outer radius R2 [mm]
  real(kind=fPrec), save :: elens_r1(nelens)          ! inner radius R1 [mm]
  real(kind=fPrec), save :: elens_offset_x(nelens), elens_offset_y(nelens)  ! hor./vert. offset of elens [mm]
  real(kind=fPrec), save :: elens_sig(nelens)         ! sig (Gaussian profile) [mm]
  real(kind=fPrec), save :: elens_geo_norm(nelens)    ! normalisation of f(r)
  real(kind=fPrec), save :: elens_len(nelens)         ! length of eLens (e-beam region) [m]
  real(kind=fPrec), save :: elens_I(nelens)           ! current of e-beam [A]
  real(kind=fPrec), save :: elens_Ek(nelens)          ! kinetic energy of e-beam [keV]


contains


  subroutine elens_kick(jelens)

    ! M. Fitterer (FNAL), and A. Mereghetti (CERN, BE-ABP-HSS)
    ! last modified: 28-02-2018
    ! apply kick of electron lens
    
    use crcoall
    use mod_common
    use mod_commonmn
    use mathlib_bouncer
    use numerical_constants
    use physical_constants
+ca commonm1
        
    real(kind=fPrec) :: xx, yy, rr, frr
    integer          :: j, jelens
        
    do j=1,napx
       
       ! 1) apply offset of e-lens
       xx=xv(1,j)-elens_offset_x(jelens)
       yy=xv(2,j)-elens_offset_y(jelens)
       
       ! 2) calculate radius of particle relative to center of elens beam
       rr=sqrt(xx**2+yy**2)
       
       ! 3) calculate kick
       !    shape function: spatial charge density depends on type:
       !    0        if r < R1
       !    frr if R1 < r < R2
       !    1        if r > R2
       if (rr.gt.elens_r1(jelens)) then ! rr <= r1 -> no kick from elens
          if (rr.lt.elens_r2(jelens)) then ! r1 < rr < r2
             select case (elens_type(jelens))
             case (1)
                ! UNIFORM: eLens with uniform profile
                ! formula: (r^2-r1^2)/(r2^2-r1^2)
                ! NB: take into account negative charge!
                frr=-( (rr+elens_r1(jelens))*(rr-elens_r1(jelens)) )/elens_geo_norm(jelens)
             case (2)
                ! GAUSSIAN: eLens with Gaussian profile
                ! formula: (exp(-r1^2/2sig^2)-exp(-r^2/2sig^2))/(exp(-r1^2/2sig^2)-exp(-r2^2/2sig^2))
                ! NB: take into account negative charge!
                frr=-( exp_mb(-0.5*(elens_r1(jelens)/elens_sig(jelens))**2)    &
                      -exp_mb(-0.5*(rr              /elens_sig(jelens))**2) )/ &
                       elens_geo_norm(jelens)
             end select
          else ! r1 < r2 <= rr
             frr=one
          endif
          ! get actual kicks from frr
          frr = elens_r2(jelens)/rr *frr *elens_theta_r2(jelens)
          ! split kick in its two components and take into account magnetic rigidity:
          yv(1,j)=yv(1,j)+frr*xx/rr*oidpsv(j)
          yv(2,j)=yv(2,j)+frr*yy/rr*oidpsv(j)
       endif
    end do
    return
    
  end subroutine elens_kick
      
      
  subroutine elens_comnul
        
    ! M. Fitterer (FNAL), A. Mereghetti (CERN, BE-ABP-HSS)
    ! last modified: 09-02-2018
    ! always in main code
    
    ! elensparam - used for tracking (parameters of single element)
    
    use mod_common
    use mod_commonmn
    use numerical_constants
    
    integer          :: i
    
    do i=1,nele
       ielens(i) = 0
    end do
    melens=0
    do i=1,nelens
       elens_type(i)          = 0
       elens_theta_r2(i)      = zero
       elens_r2(i)            = zero
       elens_r1(i)            = zero
       elens_offset_x(i)      = zero
       elens_offset_y(i)      = zero
       elens_sig(i)           = zero
       elens_geo_norm(i)      = zero
       elens_len(i)           = zero
       elens_I(i)             = zero
       elens_Ek(i)            = zero
    end do
    return
  end subroutine elens_comnul
  
  
  real(kind=fPrec) function elens_ctheta_r2( len, Int, Ekin, r2 )
    
    ! A.Mereghetti, BE-ABP-HSS
    ! last modified: 2018-02-21
    ! always in main code
    
    ! compute eLens theta at r2
    ! input variables:
    ! - length of eLens [m];
    ! - current intensity of e-beam [A]
    ! - kinetic energy of electrons [keV]
    ! - outer radius [mm]
    
    use mathlib_bouncer
    use physical_constants
    use mod_common
    use numerical_constants
+ca commonm1
        
    real(kind=fPrec) gamma, beta_e, beta_b, brho, len, Int, Ekin, r2
    gamma=Ekin*c1m3/pmae+1 ! from kinetic energy
    beta_e=sqrt((gamma+one)*(gamma-one))/(gamma)
    beta_b=e0f*gammar/pma
    brho=e0f/(clight*c1m6)
    ! r2: from mm to m
    ! theta: from rad to mrad
    elens_ctheta_r2=len*abs(Int)/(2*pi*eps0*brho*clight**2*r2*c1m3)*c1e3
    if ( Int.lt.zero ) then
       elens_ctheta_r2=elens_ctheta_r2*(one/(beta_e*beta_b)+one)
    else
       elens_ctheta_r2=elens_ctheta_r2*(one/(beta_e*beta_b)-one)
    end if
  end function elens_ctheta_r2
  
      
 end module elens
 
