+dk flukadeck
+if fluka

      subroutine check_coupling_integrity
!
!-----------------------------------------------------------------------
!     A.Mereghetti, for the FLUKA Team
!     last modified: 17-07-2013
!     check that an entrance MARKER is followed by an exit one in the
!        accelerator sequence, even though not immediately
!     inserted in main code by the 'fluka' compilation flag
!-----------------------------------------------------------------------

      use floatPrecision
      use mod_fluka
      implicit none

+ca parpro
+ca common
+ca commontr

!     temporary variables
      integer i1 , i2
      integer ix1, ix2
      integer istart, istop
      logical lerr, lfound, lcurturn

      lerr = .false.

      write (*,*) ''
      write (*,10010)
      write (*,*) ' CALL TO CHECK_COUPLING_INTEGRITY '
      write (*,*) ' NB: only entrance/exit markers are listed;'
      write (*,*) '     a single entry is by definition righteous'
      write (*,10010)
      write (*,*) ''
      write (*,*) ''
      write (*,*) '        keys to FLUKA types:'
      write (*,*) FLUKA_ELEMENT,' --> simple element'
      write (*,*) FLUKA_ENTRY,' --> entrance point'
      write (*,*) FLUKA_EXIT,' --> exit point'
      write (*,*) ''
      write (*,*) ''

      i1=1
      do while ( i1.le.iu )
        if(ktrack(i1).ne.1.and.ic(i1).gt.nblo) then
!         SINGLE ELEMENT
          ix1=ic(i1)-nblo
          if ( fluka_type(ix1).eq.FLUKA_ENTRY ) then
            write (*,*) ''
            write (*,*) ''
            write (*,10020) 'entry type', 'name', 'ID SING EL ID struct', 'ID geom'
            write(*,10030) fluka_type(ix1), bez(ix1), ix1, i1, fluka_geo_index(ix1)
            istart = i1+1
            istop  = iu
            lcurturn = .true.
            lfound = .false.
 1982       continue
            do i2=istart,istop
              if(ktrack(i2).ne.1.and.ic(i2).gt.nblo) then
!               SINGLE ELEMENT
                ix2=ic(i2)-nblo
                if ( fluka_type(ix2).eq.FLUKA_EXIT ) then
                  if(fluka_geo_index(ix1).eq.fluka_geo_index(ix2))then
                    write(*,10030) fluka_type(ix2), bez(ix2), ix2, i2, fluka_geo_index(ix2)
                    call contour_aperture_markers( i1, i2, .true.  )
                    i1 = i2 + 1
                    lfound = .true.
                    if ( lcurturn ) then
                      exit
                    else
                      goto 1983
                    endif
                  else
                    write(*,10030) fluka_type(ix2), bez(ix2), ix2, i2, fluka_geo_index(ix2)
                    write(*,*) 'ERROR! un-matched geo index'
                    write(*,*) ''
                    lerr = .true.
                  endif
                elseif ( fluka_type(ix2).ne.FLUKA_NONE ) then
                  write(*,*) 'ERROR! non-exit point when entrance is on'
                  write(*,*) ''
                  write(*,10030) fluka_type(ix2), bez(ix2), ix2, i2, fluka_geo_index(ix2)
                  lerr = .true.
                endif
              endif
            enddo
            if ( .not. lfound ) then
              if ( lcurturn ) then
!               the exit marker was not found: maybe the fluka insertion
!                  is across the end/beginning of the accelerator structure;
!               -> restart the research, upstream of the entrance marker:
                istart = 1
                istop  = i1
                lcurturn = .false.
                goto 1982
              else
!               failing research:
!               NB: in principle, this should never happen, but let's be picky
                write(*,*)'ERROR! entrance point does not have the exit'
                write(*,*)''
                lerr = .true.
              endif
            endif
          endif
        endif

!       go to next accelerator entry
        i1 = i1+1
      enddo

 1983 continue
      if ( lerr ) then
        write(*,*) ' at least one inconsistency in flagging elements'
        write(*,*) '    for coupling: please check carefully...'
        call prror(-1)
      endif

!     au revoir:
      return
10010 format(132('-'))
10020 format(1X,A10,1X,A4,12X,3(1X,A10))
10030 format(1X,I10,1X,A16,3(1X,I10))
      end subroutine

      subroutine kernel_fluka_element( nturn, i, ix )
!
!-----------------------------------------------------------------------
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 07-02-2014
!     'transport' subroutine, for a Fluka insertion corresponding to a
!       single SINGLE ELEMENT, of non-zero length
!     inserted in main code by the 'fluka' compilation flag
!-----------------------------------------------------------------------
!
      use floatPrecision
      use mod_fluka
      implicit none

+ca parpro
+ca common
+ca commonmn
+ca commonm1
+ca commontr

!     interface variables:
      integer nturn, i, ix

!     temporary variables
      integer ret, j
      double precision eltot

      save

      eltot = fluka_synch_length( ix )

      if (fluka_debug) then
!        where are we?
         write(fluka_log_unit,*)'# In fluka element of type ', fluka_type(ix)
         write(fluka_log_unit,*)'#   i=', i
         write(fluka_log_unit,*)'#   ix=', ix
         write(fluka_log_unit,*)'#   fluka_geo_index=',fluka_geo_index(ix)
         write(fluka_log_unit,*)'#   eltot=',eltot
      end if

      ret = fluka_send_receive( nturn, fluka_geo_index(ix), eltot, napx, xv(1,:), yv(1,:), xv(2,:), yv(2,:), sigmv, ejv )

      if (ret.eq.-1) then
         write(*,*)'[Fluka] Error in Fluka communication in kernel_fluka_element...'
         write(fluka_log_unit,*)'# Error in Fluka communication in kernel_fluka_element...'
         call prror(-1)
      end if

!     protons to be tracked
      do j=1,napx
!        Update values related to losses
         nlostp(j) = j
         pstop (j) = .false.
!        Update variables depending on total energy
         ejfv  (j) = sqrt((ejv(j)-pma)*(ejv(j)+pma))
         rvv   (j) = (ejv(j)*e0f)/(e0*ejfv(j))
         dpsv  (j) = (ejfv(j)-e0f)/e0f
         oidpsv(j) = 1.0D+00/(1.0D+00+dpsv(j))
         dpsv1 (j) = (dpsv(j)*1.0D+03)*oidpsv(j)
      end do

!     empty places
      do j=napx+1,npart
!        Update values related to losses
         nlostp(j) = j
         pstop (j) = .true.
!        Update values related to momentum
         ejv   (j) = 0.0D+00
         rvv   (j) = 1.0D+00
         ejfv  (j) = 0.0D+00
         dpsv  (j) = 0.0D+00
         oidpsv(j) = 1.0D+00
         dpsv1 (j) = 0.0D+00
      end do

!     au revoir:
      return
      end subroutine

      subroutine kernel_fluka_entrance( nturn, i, ix )
!
!-----------------------------------------------------------------------
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 07-02-2014
!     'transport' subroutine, for the marker starting a Fluka insertion
!     inserted in main code by the 'fluka' compilation flag
!-----------------------------------------------------------------------
!
      use floatPrecision
      use mod_fluka
      implicit none

+ca parpro
+ca common
+ca commonmn

!     interface variables:
      integer nturn, i, ix

!     temporary variables
      integer ret, j
      double precision eltot

      save

      eltot = 0.0D+00

      if (fluka_debug) then
!        where are we?
         write(fluka_log_unit,*)'# In fluka element of type ', fluka_type(ix)
         write(fluka_log_unit,*)'#   i=', i
         write(fluka_log_unit,*)'#   ix=', ix
         write(fluka_log_unit,*)'#   fluka_geo_index=',fluka_geo_index(ix)
         write(fluka_log_unit,*)'#   eltot=',eltot
      end if

      ret = fluka_send( nturn, fluka_geo_index(ix), eltot, napx, xv(1,:), yv(1,:), xv(2,:), yv(2,:), sigmv, ejv )

      if (ret.eq.-1) then
         write(*,*)'[Fluka] Error in Fluka communication in kernel_fluka_entrance...'
         write(fluka_log_unit,*)'# Error in Fluka communication in kernel_fluka_entrance...'
         call prror(-1)
      end if

!     au revoir:
      return
      end subroutine

      subroutine kernel_fluka_exit( nturn, i, ix )
!
!-----------------------------------------------------------------------
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 07-02-2014
!     'transport' subroutine, for the marker closing a Fluka insertion
!     inserted in main code by the 'fluka' compilation flag
!-----------------------------------------------------------------------
!
      use floatPrecision
      use mod_fluka
      implicit none

+ca parpro
+ca common
+ca commonmn
+ca commonm1
+ca commontr

!     interface variables:
      integer nturn, i, ix

!     temporary variables
      integer ret, j
      double precision eltot

      save

      eltot = fluka_synch_length( ix )

      if (fluka_debug) then
!        where are we?
         write(fluka_log_unit,*)'# In fluka element of type ', fluka_type(ix)
         write(fluka_log_unit,*)'#   i=', i
         write(fluka_log_unit,*)'#   ix=', ix
         write(fluka_log_unit,*)'#   fluka_geo_index=',fluka_geo_index(ix)
         write(fluka_log_unit,*)'#   eltot=',eltot
      end if

      ret = fluka_receive( nturn, fluka_geo_index(ix), eltot, napx, xv(1,:), yv(1,:), xv(2,:), yv(2,:), sigmv, ejv )

      if (ret.eq.-1) then
         write(*,*)'[Fluka] Error in Fluka communication in kernel_fluka_exit...'
         write(fluka_log_unit,*)'# Error in Fluka communication in kernel_fluka_exit...'
         call prror(-1)
      end if

!     protons to be tracked
      do j=1,napx
!        Update values related to losses
         nlostp(j) = j
         pstop (j) = .false.
!        Update variables depending on total energy
         ejfv  (j) = sqrt((ejv(j)-pma)*(ejv(j)+pma))
         rvv   (j) = (ejv(j)*e0f)/(e0*ejfv(j))
         dpsv  (j) = (ejfv(j)-e0f)/e0f
         oidpsv(j) = 1.0D+00/(1.0D+00+dpsv(j))
         dpsv1 (j) = (dpsv(j)*1.0D+03)*oidpsv(j)
      end do

!     empty places
      do j=napx+1,npart
!        Update values related to losses
         nlostp(j) = j
         pstop (j) = .true.
!        Update values related to momentum
         ejv   (j) = 0.0D+00
         rvv   (j) = 1.0D+00
         ejfv  (j) = 0.0D+00
         dpsv  (j) = 0.0D+00
         oidpsv(j) = 1.0D+00
         dpsv1 (j) = 0.0D+00
      end do

!     au revoir:
      return
      end subroutine

+ei

