+dk cheby

module cheby
  use parpro
  use floatPrecision
  implicit none

  ! A.Mereghetti (CERN, BE-ABP-HSS)
  ! last modified: 28-02-2018
  ! module for handling lenses with kicks expressed by Chebyshev polynomials
  
  integer, save          :: icheby(nele)              ! index of chebyshev lens
  integer, parameter     :: ncheby=20                 ! max number of chebyshev lenses treated (in LATTICE structure)
  integer, save          :: mcheby                    ! last chebyshev lens read
  integer, parameter     :: ncheby_tables=5           ! max number of chebyshev tables in memory (in SINGLE ELEMENT array)
  integer, save          :: mcheby_tables             ! last chebyshev table read
  
  ! variables to save parameters for tracking etc.
  real(kind=fPrec), save :: cheby_offset_x(ncheby), cheby_offset_y(ncheby)  ! hor./vert. offset [mm]
  real(kind=fPrec), save :: cheby_angle(ncheby)       ! rotation angle about the longitudinal axis [deg]
  integer, save          :: icheby_table(ncheby)      ! index of chebyshev table
  real(kind=fPrec), save :: cheby_scalingFact(ncheby) ! scaling factor []

  ! tables with chebyshev coefficients
  integer, parameter     :: cheby_unit=107            ! unit for reading the chebyshev coefficients
  integer, parameter     :: cheby_max_order=60        ! max order of chebyshev polynomials
  integer, parameter     :: cheby_lFileName=16        ! length of filenames
  character(len=cheby_lFileName), save:: cheby_filename(ncheby_tables)  ! file names
  real(kind=fPrec), save :: cheby_coeffs(0:cheby_max_order,0:cheby_max_order,ncheby_tables) ! coefficients
  integer, parameter     :: cheby_maxOrder(ncheby_tables)  ! max order of the current map
  real(kind=fPrec), save :: cheby_refRadius(ncheby_tables) ! reference radius [mm]
  

contains


  subroutine cheby_applyKick(jcheby)

    ! A. Mereghetti (CERN, BE-ABP-HSS)
    ! last modified: 20-02-2018
    ! apply kick of electron lens
    
    use crcoall
    use mod_common
    use mod_commonmn
    use mathlib_bouncer
    use numerical_constants
    use physical_constants
+ca commonm1
        
    real(kind=fPrec) :: xx, yy, rr, frr, dxp, dyp
    real(kind=fPrec) :: theta, radio, angle_rad, brho_b, beta_b
    integer          :: j, jcheby
    logical          :: lrotate
        
    ! rotation angle
    lrotate=cheby_angle(jcheby).ne.zero
    if (lrotate) angle_rad=cheby_angle(jcheby)/c180e0*pi

    ! Brho of beam
    beta_b=e0f*gammar/pma
    brho_b=e0f/(clight*c1m6)

    do j=1,napx
       
       ! apply offset
       xx=xv(1,j)-cheby_offset_x(jcheby)
       yy=xv(2,j)-cheby_offset_y(jcheby)

       ! check that particle is within the domain of chebyshev polynomials
       rr=sqrt(xx**2+yy**2)
       if (rr.gt.cheby_refRadius(icheby_table(jcheby))) then
          write(lout,*) 'ERROR in cheby_kick: particle at position (x,y,r): ',     &
               xv(1,j), xv(2,j), rr,' is outside radial domain of Chebyshev polinomials: ', &
               cheby_refRadius(icheby_table(jcheby))
          call prror(-1)
       end if
       
       ! in case of non-zero tilt angle, rotate coordinates
       if (lrotate) then
          theta = atan2_mb(yy, xx)-angle_rad
          xx = rr * cos_mb(theta)
          yy = rr * sin_mb(theta)
       end if

       ! apply kick
       call cheby_kick( xx, yy, dxp, dyp, icheby_table(jcheby), brho_b, beta_b )
       ! take into account scaling factor
       dxp=dxp *cheby_scalingFact(jcheby)
       dyp=dyp *cheby_scalingFact(jcheby)
              
       ! in case cheby has a non-zero angle, rotate kicks
       if (lrotate) then
          ! NB: cheby_angle(jcheby) is the rotation angle of the cheby
          theta = atan2_mb(dyp, dxp)+angle_rad
          radio = sqrt(dxp**2 + dyp**2)
          dxp = radio * cos_mb(theta)
          dyp = radio * sin_mb(theta)
       end if

       ! apply kicks, taking into account magnetic rigidity of particle being tracked;
       yv(1,j)=yv(1,j)+dxp *oidpsv(j)
       yv(2,j)=yv(2,j)+dyp *oidpsv(j)
    end do
    return
    
  end subroutine cheby_applyKick
      

  subroutine cheby_comnul
        
    ! A. Mereghetti (CERN, BE-ABP-HSS)
    ! last modified: 28-02-2018
    ! always in main code
    
    use mod_common
    use mod_commonmn
    use numerical_constants
    
    integer          :: i, j, i1, i2
    
    do i=1,nele
       icheby(i) = 0
    end do
    mcheby=0
    do i=1,ncheby
       icheby_table(i)      = 0
       cheby_offset_x(i)    = zero
       cheby_offset_y(i)    = zero
       cheby_angle(i)       = zero
       cheby_scalingFact(i) = one
    end do
    
    ! table with coefficients of chebyshev polynominals
    mcheby_tables=0
    do i=1,ncheby_tables
       do j=1,cheby_lFileName
          cheby_filename(i)(j:j)=' '
       end do
       do i1=0,cheby_max_order
          do i2=0,cheby_max_order
             cheby_coeffs(i1,i2,i)=zero
          end do
       end do
       cheby_refRadius(i)=zero
       cheby_maxOrder(i)=0
    end do
    return
  end subroutine cheby_comnul
  

  subroutine parseChebyFile(ifile)
    
    ! A.Mereghetti (CERN, BE-ABP-HSS)
    ! last modified: 2018-02-28
    ! always in main code
        
    ! read file with coefficients for chebyshev polynomials
    ! ifile is index of file in table of chebyshev files
    ! file is structured as:
    !    keyword : value
    ! keywords:
    ! - rad: reference radius [mm]
    ! comment line is headed by '#'
    ! coefficients are give with the following syntax:
    ! i j : value
    ! where i->x and j->y
    
    use mathlib_bouncer
    use physical_constants
    use crcoall
    use mod_common
    use numerical_constants
        
+ca comgetfields
    character(len=160) string
    integer ierr, ii, jj, ifile, errno
    real(kind=fPrec) tmpflt, beta, gamma, round_near
    
    ierr=0
    write(lout,*)' Parsing file with coefficients for Chebyshev polynomials ' &
         //cheby_filename(ifile)
    open(cheby_unit,file=cheby_filename(ifile),status='old')
    do while (.true.)
       read(cheby_unit,'(A)',end=1982,err=1983) string
       if (string(1:1).ne.'#') then
          call getfields_split( string, getfields_fields, getfields_lfields, &
               getfields_nfields, getfields_lerr )
          if ( getfields_lerr ) then
             ierr=1
             goto 1983
          end if
          
          ! actually parse the line

          if (string(1:3).eq.'rad') then
             ! read reference radius
             if (getfields_nfields.lt.3) then
                ierr=4
                goto 1983
             end if
+if .not.crlibm
             read (getfields_fields(3)(1:getfields_lfields(3)),*) tmpflt
+ei
+if crlibm
             tmpflt=round_near(errno,getfields_lfields(3)+1,getfields_fields(3))
             if (errno.ne.0) call rounderr (errno,getfields_fields,3,tmpflt)
+ei
             cheby_refRadius(ifile)=tmpflt
             if (cheby_refRadius(ifile).le.zero) then
                write(lout,*)'Elens: ERROR: reference radius of Chebyshev coefficients .le.zero'
                call prror(-1)
             end if
             
          else
             ! read chebyshev coefficients
             if (getfields_nfields.ne.4) then
                ierr=5
                goto 1983
             end if
             read (getfields_fields(1)(1:getfields_lfields(1)),*) ii
             if (ii.gt.cheby_max_order) then
                ierr=6
                goto 1983
             end if
             read (getfields_fields(2)(1:getfields_lfields(2)),*) jj
             if (jj.gt.cheby_max_order) then
                ierr=7
                goto 1983
             end if
+if .not.crlibm
             read (getfields_fields(4)(1:getfields_lfields(4)),*) tmpflt
+ei
+if crlibm
             tmpflt=round_near(errno,getfields_lfields(4)+1,getfields_fields(4))
             if (errno.ne.0) call rounderr (errno,getfields_fields,4,tmpflt)
+ei
             cheby_coeffs(ii,jj,ifile)=tmpflt
             if (ii.gt.cheby_maxOrder(ifile)) cheby_maxOrder(ifile)=ii
             if (jj.gt.cheby_maxOrder(ifile)) cheby_maxOrder(ifile)=jj
          end if ! close if for keyword identification
       end if ! close if for non-comment chars
    end do
1983 write(lout,*) 'ERROR ',ierr,' while parsing file '//cheby_filename(ifile)
    call prror(-1)
1982 close(cheby_unit)
    
    ! echo parsed data
    write(lout,fmt='(/,A,1X,I4)') ' Coefficients for Chebyshev polynomials as from file ' &
          //cheby_filename(ifile)//' - #',ifile
    write(lout,fmt='(A,1X,1PE10.3)') ' - reference radius [mm]:',cheby_refRadius(ifile)
    do ii=0,cheby_max_order
       do jj=0,cheby_max_order
          if (cheby_coeffs(ii,jj,ifile).ne.zero) then
             write(lout,fmt='(2(1X,I4)," : ",1PE10.3)') ii,jj,cheby_coeffs(ii,jj,ifile)
          end if
       end do
    end do
    
  end subroutine parseChebyFile
   
  subroutine cheby_kick( xx, yy, dxp, dyp, iTable, brho_b, beta_b )
    
    ! A. Mereghetti (CERN, BE-ABP-HSS)
    ! last modified: 28-02-2018
    ! compute kicks from Chebyshev polinomials - see FermiLAB-FN-0972-APC
    
    use mathlib_bouncer
    use physical_constants
    use numerical_constants
    
    ! interface vars
    real(kind=fPrec) :: xx, yy, dxp, dyp, brho_b, beta_b
    integer          :: iTable
     
    ! temp vars
    real(kind=fPrec) :: uu, vv, Tx (0:cheby_order), Ty (0:cheby_order), &
                        kx, ky, Tpx(0:cheby_order), Tpy(0:cheby_order), &
                        fu, fv
    integer          :: ii, jj
     
    ! normalised variables
    uu=xx/cheby_refRadius(iTable)
    vv=yy/cheby_refRadius(iTable)
    ! normalisation factors of derivatives
    fu=(one-uu)*(one+uu)
    fv=(one-vv)*(one+vv)
     
    ! polynomials:
    Tx(0)=one
    Ty(0)=one
    Tx(1)=uu
    Ty(1)=vv
    do ii=2,cheby_max_order
       Tx(ii)=two*uu*Tx(ii-1)-Tx(ii-2)
       Ty(ii)=two*vv*Ty(ii-1)-Ty(ii-2)
    end do
    ! derivatives:
    Tpx(0)=zero
    Tpy(0)=zero
    do ii=1,cheby_max_order
       Tpx(ii)=real(ii,fPrec)*(Tx(ii-1)-uu*Tx(ii))/fu
       Tpy(ii)=real(ii,fPrec)*(Ty(ii-1)-vv*Ty(ii))/fv
    end do
     
    ! get kicks
    dxp=zero
    dyp=zero 
    do ii=0,cheby_maxOrder(iTable)
       do jj=0,ii
          dxp=dxp+cheby_coeffs(jj,ii,iTable)*Tpx(jj)*Ty (ii-jj)
          dyp=dyp+cheby_coeffs(jj,ii,iTable)*Tx (jj)*Tpy(ii-jj)
       end do
    end do
    dxp=-dxp/cheby_refRadius(iTable)
    dyp=-dyp/cheby_refRadius(iTable)
    
    ! take into account Brho and beta
    dxp=dxp/(brho_b*clight*beta_b)
    dyp=dyp/(brho_b*clight*beta_b)
     
   end subroutine cheby_kick
   
   
end module cheby
