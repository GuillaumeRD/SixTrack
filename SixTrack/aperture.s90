+dk aperture

module aperture
  ! Aperture check module
  ! A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
  ! J.Molson, BE/ABP-HSS
  ! K.Sjobak, BE/ABP-LAT

  use floatPrecision
  use mathlib_bouncer
  use numerical_constants
  
  use parpro !For nele, npart

  !contains pstop(npart) etc
  use mod_commonmn
  use crcoall
  use mod_common
  use mod_commons
  
  use mod_hions
  
  implicit none
  
  ! A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
  ! last modified: 02-03-2018
  ! always in main code

  logical, save :: limifound                       ! limi block in fort.3

  integer, allocatable, save :: kape(:)            ! type of aperture (nele)
  ! aperture parameteres ape(9,nele)
  ! ape(1,:): hor dimension (RECT/RECTELLIPSE/OCT) [mm]
  ! ape(2,:): ver dimension (RECT/RECTELLIPSE/OCT) [mm]
  ! ape(3,:): hor dimension (CIRC/ELLI/RECTELLIPSE/RACETR) [mm]
  ! ape(4,:): ver dimension (CIRC/ELLI/RECTELLIPSE/RACETR) [mm]
  ! ape(5,:): m of sloped side (OCT) []
  ! ape(6,:): q of sloped side (OCT) [mm]
  ! ape(7,:): tilt angle of marker (all) [rad]
  ! ape(8,:): hor offset of marker (all) [mm]
  ! ape(9,:): ver offset of marker (all) [mm]
  real(kind=fPrec), allocatable, save ::  ape(:,:)
  logical, allocatable, save :: lapeofftlt(:)      ! aperture is tilted/offcentred (nele)

  ! save (i.e. do not kill) lost particles
  logical, save :: apflag                          ! save or not
  integer, save :: plost(npart)                    ! particle ID

  ! dump aperture profile:
  logical, save :: ldmpaper                        ! dump or not
  integer, save :: aperunit                        ! fortran unit
  character(len=16), save :: aper_filename         ! file name
  logical, save :: ldmpaperMem                     ! dump aperture marker parameters as in memory
  ! load aperture markers from external file:
  integer, save :: loadunit                        ! fortran unit
  character(len=16), save :: load_file             ! file name

  ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
  ! last modified: 02-03-2018
  ! variables for back-tracking
  logical, save :: lbacktracking                   ! activate back-tracking
  real(kind=fPrec), save :: xLast(2,npart)         ! position after last thick element [mm]
  real(kind=fPrec), save :: yLast(2,npart)         ! angles after last thick element [mrad]
  real(kind=fPrec), save :: bktpre                 ! precision of back-tracking [m]
  integer, save :: iLast, ixLast                   ! indeces of last aperture marker
  integer, save :: iLastThick, ixLastThick         ! indeces of last thick element
  integer, save :: iBckTypeLast                    ! map of back-tracking - it follows kz values, eg:
                                                   ! 0 : drift (the only one available)

  ! A.Mereghetti (CERN, BE/ABP-HSS), 2018-03-22
  ! x-sec at specific locations
  integer, save :: mxsec                           ! current number of requested x-secs
  integer, parameter :: nxsec=10                   ! max number of requested x-secs
  integer, save :: xsecunit(nxsec)                 ! fortran units
  character(len=16), save :: xsec_filename(nxsec)  ! file names
  real(kind=fPrec), save :: sLocMin(nxsec), sLocMax(nxsec), sLocDel(nxsec) ! locations
  
  
  ! aperture types  -- kape
  ! no aperture     -- 0
  ! circle          -- 1
  ! rectangle       -- 2
  ! ellipse         -- 3
  ! rectellipse     -- 4
  ! octagon         -- 5
  ! racetrack       -- 6
  ! transition      -- 7
  character(len=2), parameter, dimension(-1:6) ::  &
 &               apeName=(/'TR','NA','CR','RE','EL','RL','OC','RT'/)

  ! precision parameters:
  real(kind=fPrec), parameter :: aPrec=c1m6 ! identify two ap. markers as identical [mm]
  real(kind=fPrec), parameter :: sPrec=c1m7 ! identify two ap. markers as at the same s-pos [m]


contains


subroutine aperture_allocate_arrays
  implicit none
  integer stat
  
  call alloc(kape,nele,0,'kape')
  call alloc(lapeofftlt,nele,.FALSE.,'lapeofftlt')
  call alloc(ape,9,nele,zero,'ape')
end subroutine aperture_allocate_arrays


subroutine aperture_expand_arrays(nele_new)
  implicit none
  integer, intent(in) :: nele_new

  call resize(kape,nele_new,0,'kape')
  call resize(lapeofftlt,nele_new,.FALSE.,'lapeofftlt')
  call resize(ape,9,nele_new,zero,'ape')
  
end subroutine aperture_expand_arrays


subroutine aperture_comnul

  use numerical_constants
  implicit none
  integer ii, jj

  limifound=.false.

  apflag=.false.
  do ii=1,npart
     plost(ii)=0
  end do

  ldmpaper      = .false.
  aperunit      = 0
  aper_filename = ' '
  ldmpaperMem   = .false.
  loadunit      = 3 ! default: read aperture markers in fort.3
  load_file     = ' '

  lbacktracking = .false. ! backtracking off by default
  do ii=1,npart
     do jj=1,2
        xLast(jj,ii)=zero
        yLast(jj,ii)=zero
     end do
  end do
  bktpre=c1m1 ! default precision: 0.1m
  iLast = 0
  ixLast = 0
  iLastThick = 0
  ixLastThick = 0
  iBckTypeLast = 0

  mxsec = 0
  do ii=1,nxsec
     xsecunit(ii)=0
     xsec_filename(ii)=' '
     sLocMin(ii)=zero
     sLocMax(ii)=zero
     sLocDel(ii)=zero
  enddo

  return

end subroutine aperture_comnul


subroutine aperture_nul( ix )
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE-ABP-HSS), 2018-03-21
  ! initialise aperture marker to null
  !-----------------------------------------------------------------------
  implicit none
  integer ix, jj
  kape(ix)=0
  do jj=1,9
     ape(jj,ix)=zero
  end do
  lapeofftlt(ix)=.false.
end subroutine aperture_nul


subroutine aperture_initCR( ix, aper )
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE-ABP-HSS), 2018-03-21
  ! initialise aperture marker to circle
  !-----------------------------------------------------------------------
  implicit none
  integer ix
  real(kind=fPrec) aper
  call aperture_nul( ix )
  kape(ix)=1
  ape(1,ix)=aper
  ape(2,ix)=aper
  ape(3,ix)=aper
  ape(4,ix)=aper
  ape(5,ix)=-one
  ape(6,ix)=ape(1,ix)*sqrt(two)
end subroutine aperture_initCR


subroutine aperture_initRE( ix, aprx, apry )
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE-ABP-HSS), 2018-03-21
  ! initialise aperture marker to rectangle
  !-----------------------------------------------------------------------
  implicit none
  integer ix
  real(kind=fPrec) aprx, apry
  call aperture_nul( ix )
  kape(ix)=2
  ape(1,ix)=aprx
  ape(2,ix)=apry
  ape(3,ix)=aprx*sqrt(two)
  ape(4,ix)=apry*sqrt(two)
  ape(5,ix)=-one
  ape(6,ix)=ape(2,ix)-ape(5,ix)*ape(1,ix)
end subroutine aperture_initRE


subroutine aperture_initEL( ix, apex, apey )
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE-ABP-HSS), 2018-03-21
  ! initialise aperture marker to ellipse
  !-----------------------------------------------------------------------
  implicit none
  integer ix
  real(kind=fPrec) apex, apey
  call aperture_nul( ix )
  kape(ix)=3
  ape(1,ix)=apex
  ape(2,ix)=apey
  ape(3,ix)=apex
  ape(4,ix)=apey
  ape(5,ix)=-one
  ape(6,ix)=sqrt(ape(3,ix)**2+ape(4,ix)**2)
end subroutine aperture_initEL


subroutine aperture_initRL( ix, aprx, apry, apex, apey )
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE-ABP-HSS), 2018-03-21
  ! initialise aperture marker to rectellipse
  !-----------------------------------------------------------------------
  implicit none
  integer ix
  real(kind=fPrec) aprx, apry, apex, apey
  call aperture_nul( ix )
  kape(ix)=4
  ape(1,ix)=aprx
  ape(2,ix)=apry
  ape(3,ix)=apex
  ape(4,ix)=apey
  ape(5,ix)=-one
  ape(6,ix)=max(ape(2,ix)-ape(5,ix)*ape(1,ix),sqrt(ape(3,ix)**2+ape(4,ix)**2))
end subroutine aperture_initRL


subroutine aperture_initOC( ix, aprx, apry, theta1, theta2 )
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE-ABP-HSS), 2018-03-21
  ! initialise aperture marker to octagon
  !-----------------------------------------------------------------------
  implicit none
  integer ix
  real(kind=fPrec) aprx, apry, theta1, theta2, N
  call aperture_nul( ix )
  kape(ix)=5
  ape(1,ix)=aprx
  ape(2,ix)=apry
  ! x1=aprx=ape(1,ix)
  ! y1=ape(1,ix)*tan(theta1)
  ! x2=ape(2,ix)/tan(theta2)
  ! y2=apry=ape(2,ix)
  ! ellipse circumscribed to octagon
  ! N=x1^2*y2^2-y1^2*x2^2
  ! a=sqrt(N/(y2^2-y1^2))
  ! b=sqrt(N/(x1^2-x2^2))
  N=((ape(1,ix)*ape(2,ix))*(one+tan_mb(theta1)/tan_mb(theta2)))* &
 &  ((ape(1,ix)*ape(2,ix))*(one-tan_mb(theta1)/tan_mb(theta2)))
  ape(3,ix)=sqrt(N/((ape(2,ix)+ape(1,ix)*tan_mb(theta2))*(ape(2,ix)-ape(1,ix)*tan_mb(theta2))))
  ape(4,ix)=sqrt(N/((ape(1,ix)+ape(2,ix)/tan_mb(theta2))*(ape(1,ix)-ape(2,ix)/tan_mb(theta2))))
  ! m and q of sloped side
  ! m = (y2-y1)/(x2-x1)
  ! q = y1 -m*x1
  ape(5,ix)=(ape(2,ix)-ape(1,ix)*tan_mb(theta1))/(ape(2,ix)/tan_mb(theta2)-ape(1,ix))
  ape(6,ix)=ape(1,ix)*tan_mb(theta1)-ape(5,ix)*ape(1,ix)
end subroutine aperture_initOC


subroutine aperture_initRT( ix, aprx, apry, radius )
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE-ABP-HSS), 2018-03-22
  ! initialise aperture marker to racetrack
  !-----------------------------------------------------------------------
  implicit none
  integer ix
  real(kind=fPrec) aprx, apry, radius
  call aperture_nul( ix )
  kape(ix)=6
  ape(1,ix)=aprx
  ape(2,ix)=apry
  ape(3,ix)=radius
  ape(4,ix)=radius
  ape(5,ix)=-one
  ape(6,ix)=sqrt(ape(3,ix)**2+ape(4,ix)**2)+(ape(1,ix)-ape(3,ix))+(ape(2,ix)-ape(4,ix))
end subroutine aperture_initRT


subroutine aperture_initTR( ix, aprx, apry, apex, apey, theta1, theta2 )
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE-ABP-HSS), 2018-03-21
  ! initialise aperture marker to transition
  !-----------------------------------------------------------------------
  implicit none
  integer ix
  real(kind=fPrec) aprx, apry, apex, apey, theta1, theta2
  call aperture_nul( ix )
  kape(ix)=5
  ape(1,ix)=aprx
  ape(2,ix)=apry
  ape(3,ix)=apex
  ape(4,ix)=apey
  ! x1=aprx=ape(1,ix)
  ! y1=ape(1,ix)*tan_mb(theta1)
  ! x2=ape(2,ix)/tan_mb(theta2)
  ! y2=apry=ape(2,ix)
  ! m and q of sloped side
  ! m = (y2-y1)/(x2-x1)
  ! q = y1 -m*x1
  ape(5,ix)=(ape(2,ix)-ape(1,ix)*tan_mb(theta1))/(ape(2,ix)/tan_mb(theta2)-ape(1,ix))
  ape(6,ix)=ape(1,ix)*tan_mb(theta1)-ape(5,ix)*ape(1,ix)
end subroutine aperture_initTR


subroutine aperture_initroffpos( ix, tilt, xoff, yoff )
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE-ABP-HSS), 2018-03-22
  ! initialise offset/tilt of aperture marker
  !-----------------------------------------------------------------------
  implicit none
  integer ix
  real(kind=fPrec) tilt, xoff, yoff
  ape(7,ix)=tilt
  ape(8,ix)=xoff
  ape(9,ix)=yoff
  lapeofftlt(ix)=ape(7,ix).ne.zero.or.ape(8,ix).ne.zero.or.ape(9,ix).ne.zero
end subroutine aperture_initroffpos


subroutine aperture_saveLastMarker( i, ix )
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE-ABP-HSS), 2018-03-07
  ! save last aperture marker
  !-----------------------------------------------------------------------

  implicit none
  ! interface variables
  integer i, ix
  iLast = i
  ixLast = ix
  return

end subroutine aperture_saveLastMarker


subroutine aperture_saveLastCoordinates( i, ix, iBack )
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE-ABP-HSS), 2018-03-21
  ! save particle coordinates at last aperture check
  !-----------------------------------------------------------------------

  use mod_commonmn ! for napx, xv and yv
  implicit none
  ! interface variables
  integer i, ix, iBack
  ! temporary variables
  integer j

  do j=1,napx
     xLast(1,j) = xv(1,j)
     xLast(2,j) = xv(2,j)
     yLast(1,j) = yv(1,j)
     yLast(2,j) = yv(2,j)
  end do
  iLastThick = i
  ixLastThick = ix
  iBckTypeLast = iBack
  return

end subroutine aperture_saveLastCoordinates


subroutine aperture_backTrackingInit
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE-ABP-HSS), 2018-03-07
  ! initialise variables for back-tracking
  !-----------------------------------------------------------------------
  use parpro     ! for nblo
  use mod_common ! for ic(i)
  use crcoall    ! for lout
  implicit none
  ! temporary variables
  integer i, ix

  i=1
  ix=ic(i)-nblo
  if ( ix.lt.0 ) then
     write(lout,*)'Impossible to properly initialise backtracking: first '// &
 &   'element of lattice structure is not a single element'
     call prror(-1)
  endif
  if ( kape(i).eq.0 ) then
     write(lout,*)'Impossible to properly initialise backtracking: first '// &
 &   'element of lattice structure is not assigned an aperture profile'
     call prror(-1)
  endif

  call aperture_saveLastCoordinates( i, ix, -1 )
  call aperture_saveLastMarker( i, ix )

  return  

end subroutine aperture_backTrackingInit


subroutine lostpart(turn, i, ix, llost, nthinerr)
!-----------------------------------------------------------------------
!     P.Garcia Ortega, A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified:  8-12-2014
!     aperture check and dump lost particles
!     always in main code
!-----------------------------------------------------------------------
!     7 April 2014
!-----------------------------------------------------------------------

  use physical_constants

+if fluka
  use mod_fluka
+ei

+if root
  use iso_c_binding
  use root_output
+ei

  implicit none

! parameters
  integer turn  ! turn number
  integer i     ! element entry in the lattice
  integer ix    ! single element type index
  logical llost ! at least one particle was lost


! logical isnan
  logical myisnan
  integer ib2,ib3,ilostch,j,jj,jj1,jjx,lnapx
+ca common2
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonm1
+ca commontr
+if bnlelens
+ca rhicelens
+ei
+if collimat
! Module to access ipart array
+ca collpara
+ca dbthin6d
+ca dbcommon
+ei
+ca dbdcum

! temporary variables
  logical lparID
  integer nthinerr
  real(kind=fPrec) apxx, apyy, apxy, aps, apc, radius2
  real(kind=fPrec) xchk(2)

+if root
  character(len=max_name_len+1) this_name
+ei

! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
! last modified: 12-06-2014
! additional variables for back-tracking, when computing locations of
! lost particles
! inserted in main code by the 'backtrk' compilation flag
  integer niter       ! number of iterations
  integer kapert      ! temporal integer for aperture type
  logical llos        ! temporal logic array for interpolation
  logical lback       ! actually perform backtracking
  real(kind=fPrec) xlos(2), ylos(2), aprr(9), step, length, slos
  
  save
  
  !-----------------------------------------------------------------------
  ! check against current aperture marker
  !-----------------------------------------------------------------------

  llost=.false.
  lback=.false.
  
  if (.not.limifound.or.kape(ix).eq.0) then
    ! limi block not there or aperture type not assigned
    ! general check (set in the ITER block)
    do j=1,napx
      pstop(nlostp(j))=checkRE( xv(1,j), xv(2,j), aper(1), aper(2)).or. &
 &                       myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
      llost=llost.or.pstop(nlostp(j))
    end do
        
  else

    ! go through all possible types
    select case(kape(ix))
     
    case (-1) ! Transition
      apxx = ape(3,ix)**2.
      apyy = ape(4,ix)**2.
      apxy = apxx * apyy
      do j=1,napx
        if (lapeofftlt(ix)) then
          if (lbacktracking) then
            call roffpos(xLast(1,j),xLast(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          else 
            call roffpos(xv(1,j),xv(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          end if
          pstop(nlostp(j))=checkTR(xchk(1),xchk(2),ape(1,ix),ape(2,ix),ape(3,ix),ape(4,ix),apxx,apyy,apxy,ape(5,ix),ape(6,ix)).or. &
 &                 myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
        else
          if (lbacktracking) then
            pstop(nlostp(j))= &
 &                  checkTR(xLast(1,j),xLast(2,j),ape(1,ix),ape(2,ix),ape(3,ix),ape(4,ix),apxx,apyy,apxy,ape(5,ix),ape(6,ix)) .or. &
 &                  myisnan(xLast(1,j),xLast(1,j)).or.myisnan(xLast(2,j),xLast(2,j))
          else 
            pstop(nlostp(j))= &
 &                  checkTR(xv(1,j),xv(2,j),ape(1,ix),ape(2,ix),ape(3,ix),ape(4,ix),apxx,apyy,apxy,ape(5,ix),ape(6,ix))       .or. &
 &                  myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
          end if
        end if
        llost=llost.or.pstop(nlostp(j))
      end do
        
    case (1) ! circle
      radius2 = ape(3,ix)**2
      do j=1,napx
        if (lapeofftlt(ix)) then
          if (lbacktracking) then
            call roffpos(xLast(1,j),xLast(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          else 
            call roffpos(xv(1,j),xv(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          end if
          pstop(nlostp(j))=checkCR( xchk(1),xchk(2),radius2 ) .or. &
 &                 myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
        else
          if (lbacktracking) then
            pstop(nlostp(j))=checkCR( xLast(1,j),xLast(2,j),radius2 ) .or. &
 &                 myisnan(xLast(1,j),xLast(1,j)).or.myisnan(xLast(2,j),xLast(2,j))
          else 
            pstop(nlostp(j))=checkCR( xv(1,j),xv(2,j),radius2 ) .or. &
 &                 myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
          end if
        end if
        llost=llost.or.pstop(nlostp(j))
      end do
     
    case (2) ! Rectangle
      do j=1,napx
        if (lapeofftlt(ix)) then
          if (lbacktracking) then
            call roffpos(xLast(1,j),xLast(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          else 
            call roffpos(xv(1,j),xv(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          end if
          pstop(nlostp(j))=checkRE( xchk(1),xchk(2),ape(1,ix),ape(2,ix) ) .or. &
 &                 myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
        else
          if (lbacktracking) then
            pstop(nlostp(j))=checkRE( xLast(1,j),xLast(2,j),ape(1,ix),ape(2,ix) ) .or. &
 &                 myisnan(xLast(1,j),xLast(1,j)).or.myisnan(xLast(2,j),xLast(2,j))
          else 
            pstop(nlostp(j))=checkRE( xv(1,j),xv(2,j),ape(1,ix),ape(2,ix) ) .or. &
 &                 myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
          end if
        end if
        llost=llost.or.pstop(nlostp(j))
      end do

    case (3) ! Ellipse
      apxx = ape(3,ix)**2.
      apyy = ape(4,ix)**2.
      apxy = apxx * apyy
      do j=1,napx
        if (lapeofftlt(ix)) then
          if (lbacktracking) then
            call roffpos(xLast(1,j),xLast(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          else 
            call roffpos(xv(1,j),xv(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          end if
          pstop(nlostp(j))=checkEL( xchk(1),xchk(2),apxx,apyy,apxy ) .or. &
 &                 myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
        else
          if (lbacktracking) then
            pstop(nlostp(j))=checkEL( xLast(1,j),xLast(2,j),apxx,apyy,apxy ) .or. &
 &                 myisnan(xLast(1,j),xLast(1,j)).or.myisnan(xLast(2,j),xLast(2,j))
          else 
            pstop(nlostp(j))=checkEL( xv(1,j),xv(2,j),apxx,apyy,apxy ) .or. &
 &                 myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
          end if
        end if
        llost=llost.or.pstop(nlostp(j))
      end do
     
    case (4) ! RectEllipse
      apxx = ape(3,ix)**2.
      apyy = ape(4,ix)**2.
      apxy = apxx * apyy
      do j=1,napx
        if (lapeofftlt(ix)) then
          if (lbacktracking) then
            call roffpos(xLast(1,j),xLast(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          else 
            call roffpos(xv(1,j),xv(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          end if
          pstop(nlostp(j))=checkRL( xchk(1),xchk(2),ape(1,ix),ape(2,ix),apxx,apyy,apxy ) .or. &
 &                 myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
        else
          if (lbacktracking) then
            pstop(nlostp(j))=checkRL( xLast(1,j),xLast(2,j),ape(1,ix),ape(2,ix),apxx,apyy,apxy ) .or. &
 &                 myisnan(xLast(1,j),xLast(1,j)).or.myisnan(xLast(2,j),xLast(2,j))
          else 
            pstop(nlostp(j))=checkRL( xv(1,j),xv(2,j),ape(1,ix),ape(2,ix),apxx,apyy,apxy ) .or. &
 &                 myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
          end if
        end if
        llost=llost.or.pstop(nlostp(j))
      end do
      
    case (5) ! Octagon
      do j=1,napx
        if (lapeofftlt(ix)) then
          if (lbacktracking) then
            call roffpos(xLast(1,j),xLast(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          else 
            call roffpos(xv(1,j),xv(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          end if
          pstop(nlostp(j))=checkOC(xchk(1),xchk(2),ape(1,ix),ape(2,ix),ape(5,ix),ape(6,ix)).or. &
 &                 myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
        else
          if (lbacktracking) then
            pstop(nlostp(j))=checkOC(xLast(1,j),xLast(2,j),ape(1,ix),ape(2,ix),ape(5,ix),ape(6,ix)).or. &
 &                 myisnan(xLast(1,j),xLast(1,j)).or.myisnan(xLast(2,j),xLast(2,j))
          else 
            pstop(nlostp(j))=checkOC(xv(1,j),xv(2,j),ape(1,ix),ape(2,ix),ape(5,ix),ape(6,ix)).or. &
 &                 myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
          end if
        end if
        llost=llost.or.pstop(nlostp(j))
      end do

    case (6) ! Racetrack
      !   NB: it follows the MadX definition
      apxy = ape(3,ix)**2.
      do j=1,napx
        if (lapeofftlt(ix)) then
          if (lbacktracking) then
            call roffpos(xLast(1,j),xLast(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          else 
            call roffpos(xv(1,j),xv(2,j),xchk(1),xchk(2),ape(7,ix),ape(8,ix),ape(9,ix))
          end if
          pstop(nlostp(j))=checkRT(xchk(1),xchk(2),ape(1,ix),ape(2,ix),ape(3,ix),apxy).or. &
 &                 myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
        else
          if (lbacktracking) then
            pstop(nlostp(j))=checkRT(xLast(1,j),xLast(2,j),ape(1,ix),ape(2,ix),ape(3,ix),apxy).or. &
 &                 myisnan(xLast(1,j),xLast(1,j)).or.myisnan(xLast(2,j),xLast(2,j))
          else 
            pstop(nlostp(j))=checkRT(xv(1,j),xv(2,j),ape(1,ix),ape(2,ix),ape(3,ix),apxy).or. &
 &                 myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
          end if
        end if
        llost=llost.or.pstop(nlostp(j))
      end do
     
    end select
  end if ! if(.not.limifound.or.kape(ix).eq.0)

  !-----------------------------------------------------------------------
  ! dump coordinates in case of losses
  ! if back-tracking is requested, get more detailed point of loss
  ! for the moment, only bi-section method
  !-----------------------------------------------------------------------
  
  if (llost) then

    if (lbacktracking.and.kape(ix).ne.0.and.iBckTypeLast.ne.0) then
      lback=.true.
      ! Length between elements
      length = dcum(i)-dcum(iLast)
      ! - pay attention to overflow:
      if( length .lt. zero ) length = length+tlen
      ! - pay attention to too short thick elements
      if( length .le. bktpre ) lback=.false.
    end if
    ! Number of iterations for bisection method (ln(2x/precision)/ln(2)+1)
    if (lback) niter=nint(1.442695040889_fPrec*log_mb(two*length/bktpre)+2)
    
    do j=1,napx
      if(pstop(nlostp(j))) then
        ! treat a lost particle

        ! ==============================================================
        ! point of loss
        if (lback) then
          ! A. Mereghetti and P. Garcia Ortega, for the FLUKA Team
          ! last modified: 21-03-2018
          ! back-track particles, in order to better estimate actual loss point
           
          ylos(1)=yLast(1,j)
          ylos(2)=yLast(2,j)
               
          ! actual algorithm
          llos    = pstop(nlostp(j))
          step    = one
          do jj=1,niter
            ! current step (bisection method):
            if( llos ) then
              step = step - one / (two**(jj))
            else
              step = step + one / (two**(jj))
            end if
            ! - step discretized if last iteration, to compare with BeamLossPattern
            if(jj.eq.niter) then
              slos = int((dcum(iLast)+length*step)/bktpre+one)*bktpre
              step = (slos-dcum(iLast))/length
            end if
            ! - particle coordinates at current step
            select case(iBckTypeLast)
            case (0)
               ! back-track along a drift
               xlos(1) = xLast(1,j) -yLast(1,j)*(one-step)*length
               xlos(2) = xLast(2,j) -yLast(2,j)*(one-step)*length
               slos    = dcum(iLast)-(one-step)*length
            end select
            ! - aperture at current step
            call interp_aperture( iLast,ixLast, i,ix, kapert,aprr, slos )
            
            ! Check aperture
            if( lapeofftlt(ix).or.lapeofftlt(ixLast) ) then
              call roffpos( xlos(1), xlos(2), xchk(1),xchk(2), aprr(7), aprr(8), aprr(9) )
            else
              xchk(1) = xlos(1)
              xchk(2) = xlos(2)
            end if
            select case(kapert)
            case(-1) ! Transition
              apxx = aprr(3)**2.
              apyy = aprr(4)**2.
              apxy = apxx * apyy
              llos=checkTR(xchk(1),xchk(2),aprr(1),aprr(2),aprr(3),aprr(4),apxx,apyy,apxy,aprr(5),aprr(6)).or. &
 &                 myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
            case (1) ! Circle
              radius2 = aprr(3)**2
              llos=checkCR(xchk(1),xchk(2),radius2) .or. &
 &                  myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
            case (2) ! Rectangle
              llos=checkRE(xchk(1),xchk(2),aprr(1),aprr(2)) .or. &
 &                  myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
            case (3) ! Ellipse
              apxx = aprr(3)**2.
              apyy = aprr(4)**2.
              apxy = apxx * apyy
              llos=checkEL( xchk(1),xchk(2),apxx,apyy,apxy )  .or. &
 &                  myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
            case (4) ! RectEllipse
              apxx = aprr(3)**2.
              apyy = aprr(4)**2.
              apxy = apxx * apyy
              llos = checkRL( xchk(1),xchk(2),aprr(1),aprr(2),apxx, apyy, apxy ) .or. & 
 &                      myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
            case (5) ! Octagon
              llos=checkOC(xchk(1), xchk(2), aprr(1), aprr(2), aprr(5), aprr(6) ) .or. &
 &                    myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
            case (6) ! RaceTrack
              llos=checkRT( xchk(1), xchk(2), aprr(1), aprr(2), aprr(3), aprr(3)**2. ) .or. &
 &                    myisnan(xchk(1),xchk(1)).or.myisnan(xchk(2),xchk(2))
            end select
          end do !do jj=1,niter
          ! pay attention to overflow
          if ( slos.gt.tlen ) slos=slos-tlen
        else
          xlos(1) = xv(1,j)
          xlos(2) = xv(2,j)
          ylos(1) = yv(1,j)
          ylos(2) = yv(2,j)
          slos    = dcum(i)
        end if ! if (lback)
        

        ! ==============================================================
        ! If lost particles aren't killed, the lost info is dumped only
        ! the first time they hit the aperture. Their secondaries generated
        ! from a lost particles are considered lost as well
        if( apflag ) then
          lparID = .false.
          jjx=1
+if collimat
          do jj=1,npart
+ei
+if .not.collimat
          do jj=1,napx
+ei
            if(plost(jj).ne.0) then
+if fluka
              if( fluka_uid(j).eq.plost(jj).or. fluka_gen(j).eq.plost(jj) ) then
+ei
+if collimat
              if( ipart(j)+100*samplenumber .eq. plost(jj) ) then
+ei
+if .not.collimat.and..not.fluka
              if ( nlostp(j) .eq. plost(jj) ) then
+ei
                lparID=.true.
              end if

              jjx=jj+1 !points to the last zero 
            end if
          end do

          if(lparID) then
            !old lost particle or secondary, don't print it
            pstop(nlostp(j)) = .false.
          else
            !new lost particle, store ID and print it
+if fluka
            plost(jjx) = fluka_uid(j)
+ei
+if collimat
            plost(jjx) = ipart(j)+100*samplenumber
+ei
+if .not.collimat.and..not.fluka
            plost(jjx) = j
+ei
          end if !if(lparID) then
        end if !if( apflag ) then


        ! Print to unit 999 (fort.999)
+if fluka
        write(999,'(3(1X,I8),1X,A16,1X,F12.5,2(1X,I8),8(1X,1PE14.7),2(1X,I8))')&
+ei
+if .not.fluka
        write(999,'(3(1X,I8),1X,A16,1X,F12.5,1X,I8,7(1X,1PE14.7),2(1X,I8))')   &
+ei

     &         turn, i, ix, bez(ix), slos,                                     &
+if fluka
     &         fluka_uid(j), fluka_gen(j), fluka_weight(j),                    &
+ei
+if collimat
     &         ipart(j)+100*samplenumber,                                      &
+ei
+if .not.fluka.and..not.collimat
     &         j,                                                              &
+ei

     &         xlos(1)*c1m3, ylos(1)*c1m3, xlos(2)*c1m3, ylos(2)*c1m3,         &
     &         ejfv(j)*c1m3, (ejv(j)*(nucm0/nucm(j))-e0)*c1e6,                 &
     &         -c1m3 * (sigmv(j)/clight) * (e0/e0f),                           &
     &         naa(j), nzz(j)


+if root
! root output
        if(root_flag .and. root_ApertureCheck.eq.1) then
          this_name = trim(adjustl(bez(ix))) // C_NULL_CHAR
          call ApertureCheckWriteLossParticle(turn, i, ix, this_name, len_trim(this_name), slos, ipart(j)+100*samplenumber,&
       &  xlos(1)*c1m3, ylos(1)*c1m3, xlos(2)*c1m3, ylos(2)*c1m3, ejfv(j)*c1m3, (ejv(j)-e0)*c1e6, &
       &  -c1m3 * (sigmv(j)/clight) * (e0/e0f))
        end if
+ei ! root output

        ! Don't kill lost particle if apflag is activated
        if( apflag ) pstop(nlostp(j)) = .false.

        ! Record for postpr
        aperv(nlostp(j),1) = max(min(ape(1,ix),ape(3,ix)),c1m6) ! avoid 0.0
        aperv(nlostp(j),2) = max(min(ape(2,ix),ape(4,ix)),c1m6) ! avoid 0.0
        ixv(nlostp(j))     = ix
        xvl(1,nlostp(j))   = xlos(1)
        xvl(2,nlostp(j))   = xlos(2)
        yvl(1,nlostp(j))   = ylos(1)
        yvl(2,nlostp(j))   = ylos(2)
        dpsvl(nlostp(j))   = dpsv(j)
        ejvl(nlostp(j))    = ejv(j)
        sigmvl(nlostp(j))  = sigmv(j)
        numxv(nlostp(j))   = numx
        nnumxv(nlostp(j))  = numx
      end if ! if(pstop(nlostp(j)))
    end do ! do j=1,napx
  
    ! flush loss particle file
    flush(999)

    ! Compact array
    lnapx=napx
    do j=napx,1,-1
      if(pstop(nlostp(j))) then
        if(j.ne.lnapx) then
          do jj=j,lnapx-1
            jj1=jj+1
            nlostp(jj)=nlostp(jj1)
            xv(1,jj)=xv(1,jj1)
            xv(2,jj)=xv(2,jj1)
            yv(1,jj)=yv(1,jj1)
            yv(2,jj)=yv(2,jj1)
+if bnlelens
            namepart(jj)=namepart(jj1)
+ei
            dpsv(jj)=dpsv(jj1)
            sigmv(jj)=sigmv(jj1)
            ejfv(jj)=ejfv(jj1)
            ejv(jj)=ejv(jj1)
            rvv(jj)=rvv(jj1)
! ph: hisix
            nzz(jj)=nzz(jj1)
            naa(jj)=naa(jj1)
            nucm(jj)=nucm(jj1)
            mtc(jj)=mtc(jj1)
            moidpsv(jj)=moidpsv(jj1)
            omoidpsv(jj)=omoidpsv(jj1)
! ph: hisix
+if rvet
            rvet(jj)=rvet(jj1)
+ei
            oidpsv(jj)=oidpsv(jj1)
            dpsv1(jj)=dpsv1(jj1)
            clo6v(1,jj)=clo6v(1,jj1)
            clo6v(2,jj)=clo6v(2,jj1)
            clo6v(3,jj)=clo6v(3,jj1)
            clop6v(1,jj)=clop6v(1,jj1)
            clop6v(2,jj)=clop6v(2,jj1)
            clop6v(3,jj)=clop6v(3,jj1)

            !--beam-beam element
            di0xs(jj)=di0xs(jj1)
            dip0xs(jj)=dip0xs(jj1)
            di0zs(jj)=di0zs(jj1)
            dip0zs(jj)=dip0zs(jj1)
            do ib2=1,6
              do ib3=1,6
                tasau(jj,ib2,ib3)=tasau(jj1,ib2,ib3)
              end do
            end do
          end do !do jj=j,lnapx-1
+if fluka
          if (fluka_enable) then
            call fluka_lostpart(lnapx, j) ! Inform fluka
          end if
+ei
        end if !if(j.ne.lnapx) then
        lnapx=lnapx-1
      end if !if(pstop(nlostp(j))) then
    end do !do j=napx,1,-1
    napx=lnapx
  end if !if( llost ) then

  !-----------------------------------------------------------------------
  ! closing stuff
  !-----------------------------------------------------------------------
  
+if fluka
  napxo = napx
+ei

  if(napx.eq.0) then
    write(lout,*)
    write(lout,*)
    write(lout,*) '************************'
    write(lout,*) '** ALL PARTICLES LOST **'
    write(lout,*) '**   PROGRAM STOPS    **'
    write(lout,*) '************************'
    write(lout,*)
    write(lout,*)
+if fluka
!skip postpr
    nthinerr = 3000
+ei
+if .not.fluka
    nthinerr = 3001
    nnuml=numl
+ei
    return
  end if

end subroutine lostpart


logical function checkRE( x, y, apex, apey )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     check particle position against REctangle aperture
!     always in main code
!-----------------------------------------------------------------------
  implicit none
! parameters
  real(kind=fPrec) x, y, apex, apey
  checkRE = ( abs(x).gt.apex ).or.( abs(y).gt.apey )
  return
end function

logical function checkEL( x, y, apxx, apyy, apxy )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     check particle position against ELlipse aperture
!     always in main code
!-----------------------------------------------------------------------
  implicit none

! parameters
  real(kind=fPrec) x, y, apxx, apyy, apxy

  checkEL = x**two*apyy+y**two*apxx .gt. apxy
  return
end function checkEL

logical function checkRL( x, y, apex, apey, apxx, apyy, apxy )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     check particle position against Rect-Ellipse aperture
!     always in main code
!-----------------------------------------------------------------------
  implicit none

! parameters
  real(kind=fPrec) x, y, apex, apey, apxx, apyy, apxy

  checkRL = checkRE( x, y, apex, apey ) .or. checkEL( x, y, apxx, apyy, apxy )
  return
end function checkRL

logical function checkOC( x, y, ap1, ap2, m, q )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 22-03-2018
!     check particle position against OCtagon aperture
!     always in main code
!-----------------------------------------------------------------------
  implicit none

! parameters
  real(kind=fPrec) x, y, ap1, ap2, m, q

  checkOC = checkRE(x,y,ap1,ap2).or.(y.gt.m*x+q)
  return
end function checkOC

logical function checkRT( x, y, apex, apey, r, r2 )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 19-05-2014
!     check particle position against RaceTrack aperture
!     always in main code
!-----------------------------------------------------------------------
  implicit none

! parameters
  real(kind=fPrec) x, y, apex, apey, r, r2

  checkRT = checkRE( x, y, apex+r, apey+r ) .or. ( ( (abs(x)-apex)**2.+(abs(y)-apey)**2.).gt.r2 )
  return
end function checkRT

logical function checkCR( x, y, radius2 )
!-----------------------------------------------------------------------
!     check particle position against CiRcle aperture
!     always in main code
!-----------------------------------------------------------------------
  implicit none

! parameters
  real(kind=fPrec) x, y, radius2

  checkCR = (x**2 + y**2) .gt. radius2
  return
end function checkCR

logical function checkTR( x, y, aprx, apry, apex, apey, apxx, apyy, apxy, m, q )
!-----------------------------------------------------------------------
!     A.Mereghetti (CERN, BE/ABP-HSS)
!     last modified: 22-03-2018
!     check particle position against Transition aperture
!     always in main code
!-----------------------------------------------------------------------
  implicit none

! parameters
  real(kind=fPrec) x, y, aprx, apry, apex, apey, apxx, apyy, apxy, m, q

  checkTR = checkRL(x,y,aprx,apry,apxx,apyy,apxy).or.checkOC(x,y,aprx,apry,m,q)
  if (aprx-apex.gt.zero.and.apry-apey.gt.zero) checkTR=checkTR.or.checkRT(x,y,aprx,apry,apex,apxx)
  return
end function checkTR

subroutine roffpos( x, y, xnew, ynew, tlt, xoff, yoff )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     centre/rotate position of particles in case of offcentered/tilted 
!        aperture types
!     always in main code
!  
!     input parameters:
!        x : horizontal particle position [mm]
!        y : vertical   particle position [mm]
!        tlt:  tilt angle of the aperture profile [rad]
!        xoff: horizontal aperture offset [mm]
!        yoff: vertical   aperture offset [mm]
!
!     output parameters:
!        xnew : offcentered/tilted horizontal particle position [mm]
!        ynew : offcentered/tilted vertical   particle position [mm]
!
!-----------------------------------------------------------------------
  implicit none

! parameters
  real(kind=fPrec) x, y, xnew, ynew, tlt, xoff, yoff

! temporary variables
  real(kind=fPrec) theta, radio, xtmp, ytmp, ttmp

  xtmp = x+xoff
  ytmp = y+yoff
  theta = atan2_mb(ytmp, xtmp)
  radio = sqrt(xtmp**two + ytmp**two)
  ttmp = theta-tlt
  xnew = radio * cos_mb(ttmp)
  ynew = radio * sin_mb(ttmp)
  return
end subroutine roffpos

subroutine contour_aperture_markers( itElUp, itElDw, lInsUp )
!-----------------------------------------------------------------------
! by A.Mereghetti
! last modified: 20-12-2016
! always in main code
! check elements itElUp (upstream) and itElDw (downstream) and
!   assign them (or insert) an aperture marker, in case;
! lInsUp: force the insertion of an aperture marker upstream
!   of itElUp (.false. in case of initialisation of aperture profile
!   of entire lattice, as the upstream element is the actual entry
!   in lattice sequence);
!-----------------------------------------------------------------------
  implicit none

+ca commontr

! interface variables
  integer itElUp, itElDw
  logical lInsUp
! run time variables
  integer iElUp, iElDw, ixApeUp, ixApeDw, jj, iuold
  logical lExtremes, lsame

! do not overwrite interface variables
  iElUp=itElUp
  iElDw=itElDw
! handling extremes of lattice structure?
  lExtremes=iElUp.eq.iu.and.iElDw.eq.1

! upstream marker 
  iuold=iu
  call contour_aperture_marker( iElUp, lInsUp )
! the addition of the upstream aperture marker may have
!    shifted by one the downstream entries
! NB: if lExtremes, the upstream marker is the last entry
!     in the lattice structure! Hence, no other entry is shifted!
  if( .not.lExtremes ) then
    if( iu-iuold.ne.0 ) then
      iElDw=iElDw+(iu-iuold)
      write(lout,*) '...inserted upstream marker - downstream entries shifted by',iu-iuold
    else
      write(lout,*) '...no need to insert an upstream marker - no shift of downstream entries required.'
    end if
  end if

! downstream marker 
  iuold=iu
  call contour_aperture_marker( iElDw, .false. )
! the addition of the downstream aperture marker may have shifted by one the downstream entries
  if( iu-iuold.ne.0 ) then
! NB: if lExtremes, the downstream entry is the first entry
! in the lattice structure! Hence, if a new entry has been inserted,
! the upstream entry (at the end of the lattice structure) is
! shifted by 1
    if( lExtremes ) then
      iElUp=iElUp+(iu-iuold)
    end if
    write(lout,*) '...inserted downstream marker - downstream entries shifted by',iu-iuold
  else
    write(lout,*) '...no need to insert a downstream marker - no shift of downstream entries required.'
  end if

  if( lExtremes ) then
! check that the aperture markers at the extremities of accelerator
! lattice structure are the same
    ixApeUp=ic(iElUp)-nblo
    ixApeDw=ic(iElDw)-nblo
    lsame = sameAperture(ixApeUp,ixApeDw)
    if( .not.lsame ) then
      write(lout,*)' ERROR - different aperture markers at extremeties of accelerator lattice strucure'
      call dump_aperture_header( lout )
      call dump_aperture_marker( lout, ixApeUp, iElUp )
      call dump_aperture_marker( lout, ixApeDw, iElDw )
      call prror(-1)
    end if 
  end if

end subroutine contour_aperture_markers

subroutine contour_aperture_marker( iEl, lInsUp )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 20-12-2016
!     put an aperture marker at iEl
!     NB: it can be either a brand new entry in lattice sequence or
!         updating an existing one
!     interface variables:
!     - iEl: entry in lattice sequence to be checked
!     - lInsUp: if true, the new aperture marker is inserted upstream of iEl
!     always in main code
!-----------------------------------------------------------------------
+if fluka
! import mod_fluka
! inserted in main code by the 'fluka' compilation flag
  use mod_fluka
+ei

  implicit none

+ca commontr
+ca dbdcum
! interface variables
  integer iEl
  logical lInsUp
! temporary variables
  integer i,ix,iSrcUp,iSrcDw,iApeUp,ixApeUp,iApeDw,ixApeDw,jj,itmpape,iNew,ixNew,check_SE_unique,INEESE,INEELS,ixApeNewFrom,ixEl
  real(kind=fPrec) tmpape(9), ddcum
  logical lconst,lApeUp,lApeDw,lAupDcum,lAdwDcum,lApe,lAss,lfit

! echo of input parameters
  write(lout,*) ''
  write(lout,*)' CALL TO CONTOUR_APERTURE_MARKER...'

! check upstream element
  ixEl=ic(iEl)-nblo
  if( iEl.eq.iu ) then
! end of lattice sequence: a marker might be needed
    if( ixEl.le.0 ) then
      ix=INEESE()
      iu=INEELS( 0 )
      ic(iu)=ix+nblo
      iEl=iu
      ixEl=ix
      bez(ixEl)='e.latt.aper'
      write(lout,*) ' -> inserted empty marker at end of lattice'
    end if
  else if( iEl.eq.1 ) then
! beginning of lattice sequence: a marker might be needed
    if( ixEl.le.0 ) then
      ix=INEESE()
      iu=INEELS( 1 )
      ic(1)=ix+nblo
      iEl=1
      ixEl=ix
      bez(ixEl)='s.latt.aper'
      write(lout,*)' -> inserted empty marker at start of lattice'
+if fluka
    else if( fluka_type(ixEl).eq.FLUKA_ELEMENT.or.fluka_type(ixEl).eq.FLUKA_ENTRY   ) then
! A.Mereghetti
! last modified: 18-01-2017
! force aperture marker upstream of FLUKA_ENTRY
! inserted in main code by the 'fluka' compilation flag
      ix=INEESE()
      iu=INEELS( 1 )
      ic(1)=ix+nblo
      iEl=1
      ixEl=ix
      bez(ixEl)='s.latt.aper'
      write(lout,*) ' -> inserted empty marker at start of lattice since first entry is a FLUKA element'
+ei
    end if
  else if( ixEl.le.0 ) then
    write(lout,*) 'ERROR - lattice element at: i=',iEl
    write(lout,*) 'is NOT a SINGLE ELEMENT!'
    call prror(-1)
  end if

! echo
  write(lout,*)' look for aperture markers closest to:'
  write(lout,*)' i=',iEl,' - ix=',ixEl, ' - name: ',bez(ixEl), ' - s=',dcum(iEl)

! candidate aperture marker
  if( lInsUp ) then
    iNew=iEl-1
  else
    iNew=iEl
  end if

  ixNew=ic(iNew)-nblo
  if( iEl.eq.iu ) then
!   end of lattice sequence
    iSrcUp=iNew
    iSrcDw=1
  else if ( iEl.eq.1 ) then
!   beginning of lattice sequence:
    iSrcUp=iu
    iSrcDw=iEl
  else
    iSrcUp=iNew
    iSrcDw=iEl
  end if

! - get closest upstream aperture marker
! NB: no risk of overflow, as first/last element in lattice
! sequence should be aperture markers (and the first
! call of this function is meant to verify this assumption)
  iApeUp=-1
  ixApeUp=-1
  lApeUp=.false.
  do i=iSrcUp,1,-1
    ix=ic(i)-nblo
    if(ix.gt.0) then
!   SINGLE ELEMENT 
+if fluka
!     inserted in main code by the 'fluka' compilation flag
!     aperture markers should not coincide with a FLUKA element
      if( kape(ix).ne.0.and.fluka_type(ix).eq.FLUKA_NONE ) then
+ei
+if .not.fluka
      if( kape(ix).ne.0 ) then
+ei
        iApeUp=i
        ixApeUp=ix
        exit
      end if
    end if
  end do

  if( iApeUp.eq.-1 .and. ixApeUp.eq.-1 ) then
    write(lout,*)' ERROR - could not find upstream marker'
    call prror(-1)
  end if


! - get closest downstream aperture marker
! NB: no risk of overflow, as first/last element in lattice
! sequence should be aperture markers (and the first
! call of this function is meant to verify this assumption)
  iApeDw=-1
  ixApeDw=-1
  lApeDw=.false.
  do i=iSrcDw,iu
    ix=ic(i)-nblo
    if(ix.gt.0) then
!   SINGLE ELEMENT 
+if fluka
!     inserted in main code by the 'fluka' compilation flag
!     aperture markers should not coincide with a FLUKA element
      if( kape(ix).ne.0.and.fluka_type(ix).eq.FLUKA_NONE ) then
+ei
+if .not.fluka
      if( kape(ix).ne.0 ) then
+ei
        iApeDw=i
        ixApeDw=ix
        exit
      end if
    end if
  end do
  if( iApeDw.eq.-1 .and. ixApeDw.eq.-1 ) then
    write(lout,*)' ERROR - could not find downstream marker'
    call prror(-1)
  end if


! - echo found apertures
  call dump_aperture_header( lout )
  call dump_aperture_marker( lout, ixApeUp, iApeUp )
  call dump_aperture_marker( lout, ixApeDw, iApeDw )

! - checks:
! . iNew is iApeUp
  lApeUp=iApeUp.eq.iNew.and.ixApeUp.eq.ixNew

! . iNew is at the same s as iApeUp (inlcuding ring overvlow)
  lAupDcum=abs(dcum(iNew)-dcum(iApeUp)).lt.sPrec.or.abs(dcum(iNew)-dcum(iApeUp)-tlen).lt.sPrec

! . iNew is iApeDw
  lApeDw=iApeDw.eq.iNew.and.ixApeDw.eq.ixNew

! . iNew is at the same s as ApeDw (inlcuding ring overvlow)
  lAdwDcum=abs(dcum(iNew)-dcum(iApeDw)).lt.sPrec.or.abs(dcum(iNew)-dcum(iApeDw)-tlen).lt.sPrec

! . constant aperture?
  lconst = sameAperture( ixApeUp, ixApeDw )

! . can iNew be assigned an aperture marker?
! ie is it a single element and is it used anywhere else?
  lApe=lApeUp.or.lApeDw
  lAss=ixNew.gt.0.and.check_SE_unique(iNew,ixNew).eq.-1

! some action is needed
  if( .not.lApe ) then
! . iNew must be assigned an aperture
    ixApeNewFrom=-1
    lfit=.false.
    itmpape=0
    do jj=1,9
      tmpape(jj)=zero
    end do

!   . aperture profile
    if( lconst.or.lAupDcum ) then
!   constant aperture or upstream aperture marker at the same s-location 
!   -> it is wise to use the upstream aperture
      ixApeNewFrom=ixApeUp
    else if( lAdwDcum ) then
!   same s-location as the closest downstream aperture marker
!   -> it is wise to use it!
      ixApeNewFrom=ixApeDw
    else
!   varying aperture -> we need to interpolate
      call interp_aperture( iApeUp, ixApeUp, iApeDw, ixApeDw, itmpape, tmpape, dcum(iNew) )
      lfit=.true.
    end if

!   . aperture entry
    if( .not.lAss ) then
!     ixNew cannot be assigned an aperture marker: we have to insert
!     a new entry in the lattice sequence
      if( lfit ) then
        ixNew=INEESE()
        bez(ixNew)=CrtApeName()
      end if
      iNew=iNew+1
      iu=INEELS( iNew )
    end if

!   . assign aperture profile
    if( lAss.or.lfit ) then
!     aperture model must be copied
      call copy_aperture( ixNew,ixApeNewFrom,itmpape,tmpape )
      ic(iNew)=ixNew+nblo
    else if( ixApeNewFrom.gt.-1 ) then
!     an existing aperture model can be assigned
      ic(iNew)=ixApeNewFrom+nblo
    else
!     this should never happen
      write(lout,*)' ERROR in aperture auto assignment.'
      call prror(-1)
    end if
  end if

! echo for checking
  write(lout,*) ' ...echo results of assignment:'
  call dump_aperture_header( lout )
  call dump_aperture_marker( lout, ic(iNew)-nblo, iNew )

! go home, man
  iEl=iNew
  return

 1982 format (a16,2(1x,a2),8(1x,f15.5))
end subroutine contour_aperture_marker

character(len=max_name_len) function CrtApeName()
!-----------------------------------------------------------------------
!     by A.Mereghetti (CERN, BE/ABP-HSS)
!     last modified: 01-12-2016
!     Create Aperture Name
!     always in main code
!-----------------------------------------------------------------------
  implicit none
  integer iApe, ii
  data iApe / 0 /
  save iApe

  iApe=iApe+1
  write(CrtApeName, "(A10,I6)") "auto.aper.", iApe

  do ii=11,16
    if( CrtApeName(ii:ii) .eq. ' ' ) CrtApeName(ii:ii)='0'
  end do
end function CrtApeName

logical function sameAperture( ixApeUp, ixApeDw )
!-----------------------------------------------------------------------
!     by A.Mereghetti (CERN, BE/ABP-HSS)
!     last modified: 21-03-2018
!     Verify that two aperture markers actually describe the same aperture
!       restriction  
!-----------------------------------------------------------------------
  implicit none
  integer ixApeUp, ixApeDw, jj
  sameAperture=ixApeDw.eq.ixApeUp.or.kape(ixApeDw).eq.kape(ixApeUp)
  if (sameAperture) then
     do jj=1,9
        sameAperture=sameAperture.and.abs(ape(jj,ixApeDw)-ape(jj,ixApeUp)).lt.aPrec
        if (.not.sameAperture) exit
     end do
  end if
end function sameAperture

subroutine interp_aperture( iUp,ixUp, iDw,ixDw, oKApe,oApe, spos )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 21-03-2018
!     interpolate aperture
!     always in main code
!-----------------------------------------------------------------------
  implicit none

+ca commontr
+ca dbdcum

! interface variables
  integer iUp, ixUp, iDw, ixDw, oKApe
  real(kind=fPrec) oApe(9), spos
! temporary variables
  real(kind=fPrec) ddcum, mdcum
  integer jj

  if( sameAperture(ixUp,ixDw ) ) then
     ! constant aperture - no need to interpolate
     oKApe=kape(ixUp)
     do jj=1,9
        oApe(jj)=ape(jj,ixUp)
     end do
  else
     ! non-constant aperture - interpolate
     ! type: we may interpolate the same aperture type
     oKApe=-1 ! transition
     if ( kape(ixUp).eq.kape(ixDw) ) oKApe=kape(ixUp)

     ! actual interpolation
     ddcum = spos-dcum(iUp)
     if( ddcum.lt.zero ) ddcum=tlen+ddcum
     mdcum = dcum(iDw)-dcum(iUp)
     if( mdcum.lt.zero ) mdcum=tlen+mdcum
     do jj=1,9
        oApe(jj)=(ape(jj,ixDw)-ape(jj,ixUp))/mdcum*ddcum+ape(jj,ixUp)
     end do
  end if
  return
end subroutine interp_aperture

subroutine copy_aperture( ixApeTo, ixApeFrom, nKApe, nApe )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 02-12-2016
!     copy aperture, either from an existing one or from the one
!       received on the fly
!     always in main code
!-----------------------------------------------------------------------
  implicit none

+ca commontr
+ca dbdcum

! interface variables
  integer ixApeTo, ixApeFrom, nKApe
  real(kind=fPrec) nApe(9)
! temporary variables
  integer jj

  if( ixApeFrom.gt.0 ) then
! copy aperture marker from existing SINGLE ELEMENT
    kape(ixApeTo)=kape(ixApeFrom)
    do jj=1,9
      ape(jj,ixApeTo)=ape(jj,ixApeFrom)
    end do
  else
! copy aperture marker from temporary one
    kape(ixApeTo)=nKApe
    do jj=1,9
      ape(jj,ixApeTo)=nApe(jj)
    end do
  end if
      
end subroutine copy_aperture

subroutine dump_aperture_model
!-----------------------------------------------------------------------
!     by P.Garcia Ortega, for the FLUKA Team, and A.Mereghetti
!     last modified: 08-12-2016
!     dump all apertures declared in machine
!     always in main code
!-----------------------------------------------------------------------
  implicit none

+ca commontr
+ca dbdcum

! temporary variables
  integer i, ix
  logical lopen

  integer iOld, ixOld, niter, oKApe, jj
  real(kind=fPrec) aprr(9),slos

  write(lout,*)''
  write(lout,fmt="(131('-'))")
  write(lout,*)''
  write(lout,*)' DUMP OF APERTURE MODEL'
  write(lout,*)''

  inquire( unit=aperunit, opened=lopen )
  if( .not.lopen ) then
    if( aperunit.ne.0 ) then
       open( aperunit, file=aper_filename, form='formatted' )
       write(lout,*) 'APERTURE PROFILE DUMPED IN FILE: ',aper_filename,' - UNIT: ',aperunit
    end if
  end if

! Header
  call dump_aperture_header( aperunit )

! First element of lattice
  i=1
  ix=ic(i)-nblo
  if( kape(ix).eq.0 ) then
    write(lout,*) ' ERROR - first element of lattice structure is not assigned any aperture type'
    call prror(-1)
  end if
  call dump_aperture_marker( aperunit, ix, i )

  do i=2,iu
    ix=ic(i)-nblo
    if(ix.gt.0) then
      ! SINGLE ELEMENT 
      if( kape(ix) .ne. 0 ) then
        if (lbacktracking) then
          ! Number of iterations 
          if( (dcum(i)-dcum(iOld)).gt.zero) then
            niter = nint((dcum(i)-dcum(iOld))/bktpre+1)
            do jj=1,niter
              slos = int(dcum(iOld)/bktpre+jj)*bktpre
              if ( slos.lt.dcum(iOld) .or. slos.gt.dcum(i) ) exit
              call interp_aperture(iOld,ixOld,i,ix,oKApe,aprr,slos)
              call dump_aperture( aperunit, bez(ix), oKApe, slos, aprr )
            end do
          end if
          iOld=i
          ixOld=ix
        else
          call dump_aperture_marker( aperunit, ix, i )
        endif
      end if
    end if
  end do

  return

end subroutine dump_aperture_model

subroutine dumpMe
  implicit none

+ca commontr
+ca dbdcum

! temporary variables
  integer i, ix

  write(lout,*) 'dumpMe - start'
  do i=1,iu
    ix=ic(i)-nblo
    if( ix.gt.0 ) then
      write(lout,*) i,bez(ix),dcum(i),kape(ix)
    else
      write(lout,*) i,bezb(ic(i)),dcum(i)
    end if
  end do

  write(lout,*) 'dumpMe - end'

end subroutine dumpMe

subroutine dump_aperture( iunit, name, aptype, spos, ape )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 08-12-2016
!     dump any aperture marker
!     always in main code
!-----------------------------------------------------------------------
  implicit none

! interface variables
  integer iunit
  integer aptype
  character(len=max_name_len) name
  real(kind=fPrec) ape(9)
  real(kind=fPrec) spos

! dump info
  if (ldmpaperMem) then
     write(iunit,1984) name, apeName(aptype), spos, ape(1), ape(2), ape(3), ape(4), ape(5), ape(6), ape(7), ape(8), ape(9)
  else
     select case(aptype)
     case(-1) ! transition
        write(iunit,1984) name, apeName(aptype), spos, ape(1), ape(2), ape(3), ape(4), ape(5), ape(6), ape(7), ape(8), ape(9)
     case(0) ! not an aperture marker
        write(iunit,1984) name, apeName(aptype), spos, ape(1), ape(2), ape(3), ape(4), ape(5), ape(6), ape(7), ape(8), ape(9)
     case(1) ! Circle
        write(iunit,1984) name, apeName(aptype), spos, ape(1),   zero,   zero,   zero,   zero,   zero, ape(7), ape(8), ape(9)
     case(2) ! Rectangle
        write(iunit,1984) name, apeName(aptype), spos, ape(1), ape(2),   zero,   zero,   zero,   zero, ape(7), ape(8), ape(9)
     case(3) ! Ellipse
        write(iunit,1984) name, apeName(aptype), spos, ape(3), ape(4),   zero,   zero,   zero,   zero, ape(7), ape(8), ape(9)
     case(4) ! Rectellipse
        write(iunit,1984) name, apeName(aptype), spos, ape(1), ape(2), ape(3), ape(4),   zero,   zero, ape(7), ape(8), ape(9)
     case(5) ! Octagon
        ! get angles from points passing through x1,y1 and x2,y2
        ! x1=ape(1)
        ! y1=ape(1)*tan(theta1)
        ! x2=ape(2)/tan(theta2)
        ! y2=ape(2)
        write(iunit,1984) name, apeName(aptype), spos, ape(1), ape(2), atan2_mb(ape(1)*ape(5)+ape(6),ape(1)), &
             &         atan2_mb(ape(2),(ape(2)-ape(6))/ape(5)),   zero,   zero, ape(7), ape(8), ape(9)
     case(6) ! Racetrack
        write(iunit,1984) name, apeName(aptype), spos, ape(1), ape(2), ape(3),   zero,   zero,   zero, ape(7), ape(8), ape(9)
     end select
  end if
  return
 1984 format (1x,a16,1x,a6,10(1x,f15.5))
end subroutine dump_aperture

subroutine dump_aperture_marker( iunit, ixEl, iEl )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 08-12-2016
!     dump single aperture marker, existing in aperture DB
!     always in main code
!-----------------------------------------------------------------------
  implicit none

+ca commontr
+ca dbdcum

! interface variables
  integer iunit, iEl, ixEl

  call dump_aperture( iunit, bez(ixEl), kape(ixEl), dcum(iEl), ape(1:9,ixEl) )

  return
end subroutine dump_aperture_marker

subroutine dump_aperture_header( iunit )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 22-03-2018
!     dump header of aperture marker
!     always in main code
!-----------------------------------------------------------------------
  implicit none
  integer iunit
  write(iunit,1984) '#', 'name', 'aptype', 's[m]', 'aper1[mm]', 'aper2[mm]', &
 &                  'aper3[mm][rad]', 'aper4[mm][rad]', 'aper5[mm][rad]', 'aper6[mm][rad]', &
 &                  'angle[rad]', 'xoff[mm]', 'yoff[mm]'
  return
 1984 format (a1,a16,1x,a6,1x,10(1x,a15))
end subroutine dump_aperture_header

subroutine dump_aperture_xsecs
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE/ABP-HSS), 22-03-2018
  ! dump cross-sections of apertures at specific locations (loop)
  !-----------------------------------------------------------------------
  implicit none
  integer ixsec,ierro
  logical lopen
  real(kind=fPrec) sLoc

  ! loop over requested lines
  do ixsec=1,mxsec
     ! from print_lastlines_to_stderr
     inquire(unit=xsecunit(ixsec),opened=lopen)
     if (lopen) then
        write(lout,*)'Dump_aperture_xsecs - Error in opening unit ',xsecunit(ixsec), &
 &            ' - filename: ',xsec_filename(ixsec),' - the file is already open.'
        call prror(-1)
     end if
     open(unit=xsecunit(ixsec),file=xsec_filename(ixsec),form="formatted",status="old",iostat=ierro)
     if (ierro .ne. 0) then
        write(lout,'(a,a,a,1x,i5,1x,a,1x,i5)')                         &
     &        "Error when opening file '",                             &
     &        trim(xsec_filename(ixsec)),                              &
     &        "' on unit #", xsecunit(ixsec), ", iostat =",ierro
        call prror(-1)
     endif

     ! loop over s-locations
     sLoc=sLocMin(ixsec)
     do while(sLoc.le.sLocMax(ixsec))
        call dump_aperture_xsec(sLoc,xsecunit(ixsec))
        sLoc=sLoc+sLocDel(ixsec)
     enddo
     
     close(xsecunit(ixsec))
  enddo

  return
end subroutine dump_aperture_xsecs


subroutine dump_aperture_xsec( sLoc, iunit )
  !-----------------------------------------------------------------------
  ! A.Mereghetti (CERN, BE/ABP-HSS), 22-03-2018
  ! dump the cross-sections of the machine aperture at a specific location
  !-----------------------------------------------------------------------
  implicit none
  integer iunit
  real(kind=fPrec) sLoc
  
  return

end subroutine dump_aperture_xsec

end module aperture

