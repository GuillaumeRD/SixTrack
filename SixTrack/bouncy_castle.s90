+dk mathlib_bouncer
module mathlib_bouncer
  use floatPrecision
  implicit none

  public :: sin_mb, asin_mb, sinh_mb, cos_mb, acos_mb, cosh_mb, tan_mb, atan_mb, atan2_mb, exp_mb, log_mb, log10_mb
+if crlibm
  private :: acos_rn, asin_rn, atan2_rn
+ei
contains  !Definition of the MathlibBouncer (_mb) functions

  real(kind=fPrec) function sin_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
    !Temporary, to make linking possible
    double precision sin_rn
    
+if .not.crlibm
    !Input KIND = output KIND
    sin_mb=sin(arg)
+ei
+if crlibm
    sin_mb=sin_rn(arg)
+ei
  end function sin_mb

  real(kind=fPrec) function asin_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
+if .not.crlibm
    !Input KIND = output KIND
    asin_mb=asin(arg)
+ei
+if crlibm
    asin_mb=asin_rn(arg)
+ei
  end function asin_mb

  real(kind=fPrec) function sinh_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
    !Temporary, to make linking possible
    double precision sinh_rn
    
+if .not.crlibm
    !Input KIND = output KIND
    sinh_mb=sinh(arg)
+ei
+if crlibm
    sinh_mb=sinh_rn(arg)
+ei
  end function sinh_mb
  
  real(kind=fPrec) function cos_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
    !Temporary, to make linking possible
    double precision cos_rn
    
+if .not.crlibm
    !Input KIND = output KIND
    cos_mb=cos(arg)
+ei
+if crlibm
    cos_mb=cos_rn(arg)
+ei
  end function cos_mb
  
  real(kind=fPrec) function acos_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
+if .not.crlibm
    !Input KIND = output KIND
    acos_mb=acos(arg)
+ei
+if crlibm
    acos_mb=acos_rn(arg)
+ei
  end function acos_mb
  
  real(kind=fPrec) function cosh_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
    !Temporary, to make linking possible
    double precision cosh_rn
    
+if .not.crlibm
    !Input KIND = output KIND
    cosh_mb=cos(arg)
+ei
+if crlibm
    cosh_mb=cosh_rn(arg)
+ei
  end function cosh_mb
  
  real(kind=fPrec) function tan_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
    !Temporary, to make linking possible
    double precision tan_rn
    
+if .not.crlibm
    !Input KIND = output KIND
    tan_mb=tan(arg)
+ei
+if crlibm
    tan_mb=tan_rn(arg)
+ei
  end function tan_mb
  
  real(kind=fPrec) function atan_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
    !Temporary, to make linking possible
    double precision atan_rn
    
+if .not.crlibm
    !Input KIND = output KIND
    atan_mb=atan(arg)
+ei
+if crlibm
    atan_mb=atan_rn(arg)
+ei
  end function atan_mb
  
  real(kind=fPrec) function atan2_mb(y,x)
    implicit none
    real(kind=fPrec) y,x
    intent(in) y,x
    
+if .not.crlibm
    !Input KIND = output KIND
    atan2_mb=atan2(y,x)
+ei
+if crlibm
    atan2_mb=atan2_rn(y,x)
+ei
  end function atan2_mb

  real(kind=fPrec) function exp_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
    !Temporary, to make linking possible
    double precision exp_rn
    
+if .not.crlibm
    !Input KIND = output KIND
    exp_mb=exp(arg)
+ei
+if crlibm
    exp_mb=exp_rn(arg)
+ei
  end function exp_mb

  real(kind=fPrec) function log_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
    !Temporary, to make linking possible
    double precision log_rn
    
+if .not.crlibm
    !Input KIND = output KIND
    log_mb=log(arg)
+ei
+if crlibm
    log_mb=log_rn(arg)
+ei
  end function log_mb

  real(kind=fPrec) function log10_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
    !Temporary, to make linking possible
    double precision log10_rn
    
+if .not.crlibm
    !Input KIND = output KIND
    log10_mb=log10(arg)
+ei
+if crlibm
    log10_mb=log10_rn(arg)
+ei
  end function log10_mb
  
+if crlibm
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Functions moved from sixtrack.s, wrapping parts of crlibm !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  real(kind=real64) function acos_rn(x)
    use, intrinsic :: iso_fortran_env, only : real64
    implicit none
    real(kind=real64) atan_rn,x,pi,pi2
    logical myisnan
    data pi  /3.1415926535897932d0/
    data pi2 /1.5707963267948966d0/
    if (myisnan(x,x)) then
       acos_rn=x
    elseif (abs(x).eq.0.0d0) then
       acos_rn=pi2
    else
       !       acos_rn=atan_rn(sqrt(1.0d0-x*x)/x)
       ! Try using (1-x)*(1+x) in case x is very small.........
       ! or close to 1.....write a test program!!!
       acos_rn=atan_rn(sqrt((1.0d0-x)*(1.0d0+x))/x)
       if (x.lt.0d0) then
          acos_rn=pi+acos_rn
       endif
    endif
  end function acos_rn

  real(kind=real64) function asin_rn(x)
    use, intrinsic :: iso_fortran_env, only : real64
    implicit none
    real(kind=real64) atan_rn,x,pi2
    logical myisnan
    data pi2 /1.5707963267948966d0/
    if (myisnan(x,x)) then
       asin_rn=x
       return
    endif
    if (abs(x).eq.1.0d0) then
       asin_rn=sign(pi2,x)
    else
       !       asin_rn=atan_rn(x/sqrt(1.0d0-x*x))
       ! Try using (1-x)*(1+x) in case x is very small.........
       ! or close to 1.....write a test program!!!
       asin_rn=atan_rn(x/sqrt((1.0d0-x)*(1.0d0+x)))
    endif
  end function asin_rn

  real(kind=real64) function atan2_rn(y,x)
    use, intrinsic :: iso_fortran_env, only : real64
    implicit none
    real(kind=real64) atan_rn,x,y,pi,pi2
    logical myisnan
    data pi  /3.1415926535897932d0/
    data pi2 /1.5707963267948966d0/
    if (x.eq.0d0) then
       if (y.eq.0d0) then
          ! Should get me a NaN
          atan2_rn=atan_rn(y/x)
       else
          atan2_rn=sign(pi2,y)
       endif
    else
       if (y.eq.0d0) then
          if (x.gt.0d0) then
             atan2_rn=0d0
          else
             atan2_rn=pi
          endif
       else
          atan2_rn=atan_rn(y/x)
          if (x.lt.0d0) then
             atan2_rn=sign(pi,y)+atan2_rn
          endif
       endif
    endif
  end function atan2_rn
+ei

end module mathlib_bouncer

