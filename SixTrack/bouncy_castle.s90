+dk mathlib_bouncer
module mathlib_bouncer
  use floatPrecision
  implicit none
  
contains  !Definition of the MathlibBouncer (_mb) functions

  real(kind=fPrec) function sin_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
    !Temporary, to make linking possible
    double precision sin_rn
    
+if .not.crlibm
    !Input KIND = output KIND
    sin_mb=sin(arg)
+ei
+if crlibm
    sin_mb=sin_rn(arg)
+ei
  end function sin_mb

  real(kind=fPrec) function asin_mb(arg)
    implicit none
    real(kind=fPrec) arg
    intent(in) arg
    
    !Temporary, to make linking possible
    double precision asin_rn
    
+if .not.crlibm
    !Input KIND = output KIND
    asin_mb=asin(arg)
+ei
+if crlibm
    asin_mb=asin_rn(arg)
+ei
  end function asin_mb
  
end module mathlib_bouncer

+if crlibm

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Functions moved from sixtrack.s, wrapping parts of crlibm !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

real(kind=real64) function acos_rn(x)
  use, intrinsic :: iso_fortran_env, only : real64
  implicit none
  real(kind=real64) atan_rn,x,pi,pi2
  logical myisnan
  data pi  /3.1415926535897932d0/
  data pi2 /1.5707963267948966d0/
  if (myisnan(x,x)) then
     acos_rn=x
  elseif (abs(x).eq.0.0d0) then
     acos_rn=pi2
  else
     !       acos_rn=atan_rn(sqrt(1.0d0-x*x)/x)
     ! Try using (1-x)*(1+x) in case x is very small.........
     ! or close to 1.....write a test program!!!
     acos_rn=atan_rn(sqrt((1.0d0-x)*(1.0d0+x))/x)
     if (x.lt.0d0) then
        acos_rn=pi+acos_rn
     endif
  endif
end function acos_rn

real(kind=real64) function asin_rn(x)
  use, intrinsic :: iso_fortran_env, only : real64
  implicit none
  real(kind=real64) atan_rn,x,pi2
  logical myisnan
  data pi2 /1.5707963267948966d0/
  if (myisnan(x,x)) then
     asin_rn=x
     return
  endif
  if (abs(x).eq.1.0d0) then
     asin_rn=sign(pi2,x)
  else 
     !       asin_rn=atan_rn(x/sqrt(1.0d0-x*x))
     ! Try using (1-x)*(1+x) in case x is very small.........
     ! or close to 1.....write a test program!!!
     asin_rn=atan_rn(x/sqrt((1.0d0-x)*(1.0d0+x)))
  endif
end function asin_rn

real(kind=real64) function atan2_rn(y,x)
  use, intrinsic :: iso_fortran_env, only : real64
  implicit none
  real(kind=real64) atan_rn,x,y,pi,pi2
  logical myisnan
  data pi  /3.1415926535897932d0/
  data pi2 /1.5707963267948966d0/
  if (x.eq.0d0) then
     if (y.eq.0d0) then
        ! Should get me a NaN
        atan2_rn=atan_rn(y/x)
     else
        atan2_rn=sign(pi2,y)
     endif
  else
     if (y.eq.0d0) then
        if (x.gt.0d0) then
           atan2_rn=0d0
        else
           atan2_rn=pi
        endif
     else
        atan2_rn=atan_rn(y/x)
        if (x.lt.0d0) then
           atan2_rn=sign(pi,y)+atan2_rn
        endif
     endif
  endif
end function atan2_rn
+ei
