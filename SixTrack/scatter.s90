+dk scatter
! Deck for the scattering routines implemented in the SCATTER block

subroutine scatter_dumpdata

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

    integer ii,jj

    write(lout,'(a)') "*** BEGIN SCATTER DUMP ***"

    write(lout,'(a)') "Options:"
    write(lout,*)     "scatter_active =", scatter_active
    write(lout,*)     "scatter_debug  =", scatter_debug

    write(lout,'(a)') "Arrays:"
    write(lout,*) "scatter_ELEM: (",scatter_nELEM,",",scatter_maxGenELEM,"):"

    do ii=1, scatter_nELEM
        write(lout,*) ii, ":", scatter_ELEM(ii,:)
    end do

    write(lout,*) "scatter_PROFILE: (", scatter_nPROFILE,",",5,"):"
    do ii=1, scatter_nPROFILE
        write(lout,*) ii, ":", scatter_PROFILE(ii,:)
    end do

    write(lout,*) "scatter_GENERATOR: (",scatter_nGENERATOR,",",5,"):"
    do ii=1, scatter_nGENERATOR
        write(lout,*) ii, ":", scatter_GENERATOR(ii,:)
    end do

    write(lout,*) "scatter_idata: (",scatter_nidata,"):"
    do ii=1, scatter_nidata
        write(lout,*) ii, ":", scatter_idata(ii)
    end do

    write(lout,*) "scatter_fdata: (",scatter_nfdata,"):"
    do ii=1, scatter_nfdata
        write(lout,*) ii, ":", scatter_fdata(ii)
    end do

    write(lout,*) "scatter_cdata: (",scatter_ncdata,"):"
    do ii=1, scatter_ncdata
        write(lout,*) ii, ": '"//trim(stringzerotrim(scatter_cdata(ii)))//"'"
    end do

    write(lout,'(a)') "**** END SCATTER DUMP ****"

end subroutine

subroutine scatter_thin(ix, turn)

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

+ca common
+ca commonmn

    ! Define functions
    double precision scatter_profile_getDensity
    double precision scatter_generator_getCrossSection
    double precision scatter_generator_getPPElastic

    ! Temp variables
    integer          ELEMidx, PROidx, GENidx
    integer          i, j
    integer          tmpSeed1, tmpSeed2
    double precision s, t, xi, theta
    double precision crossSection, N, P
    double precision rndPhi(npart), rndP(npart)

    ! Input
    integer, intent(in) :: ix, turn

    ELEMidx = scatter_elemPointer(ix)
    PROidx  = scatter_ELEM(ELEMidx,2)

    !Compute the "standard" s (used for cross-sections)
    !(ask profile for the p)

    call recuut(tmpSeed1,tmpSeed2)
    call recuin(scatter_seed1,scatter_seed2)

    ! ! Code to run a test of the distribution
    ! open(13077,file="t.txt",status="replace",form="formatted")
    ! do i=1,100000000
    !     t = scatter_generator_getPPElastic(0.046d0,18.52d0,4.601d0,2.647d0,0.0d0)
    !     write(13077,*) t
    ! end do
    ! close(13077)
    ! stop

    !Loop over generators
    do i=3,scatter_maxGenELEM
        GENidx = scatter_ELEM(ELEMidx,i)
        if(GENidx .eq. 0) exit

        call ranecu(rndPhi, napx, -1)
        call ranecu(rndP,   napx, -1)
        rndPhi = rndPhi*2*3.1415926535897932d0

        do j=1, napx
            ! Compute the cross-section at this s
            ! (in most cases rougly equal for all particles; use mean x,y,xp,yp,E)
            crossSection = scatter_generator_getCrossSection( &
                & PROidx,GENidx, xv(1,j),xv(2,j),yv(1,j),yv(2,j),ejv(j) &
            &)

            ! Ask profile for density at x,y
            N = scatter_profile_getDensity(PROidx,xv(1,j),xv(2,j))
            
            ! Compute probability P
            P = N*crossSection
            ! If RNG < P -> scatter; else go to next particle
            if (rndP(j) .le. P) then ! Was .gt., but pseudo code says .lt.
                cycle
            endif
            
            ! Ask generator for t and xi
            call scatter_generator_getTandXi(GENidx,t,xi)
            
            ! Use generator t and xi to update particle j;
            ! remember to update ALL the energy arrays
            theta   = sqrt(t)/ejfv(j)
            yv(1,j) = 1d3*theta*cos(rndPhi(j)) + yv(1,j)
            yv(2,j) = 1d3*theta*sin(rndPhi(j)) + yv(2,j)

            ! Output to file
            write(667,*) turn, j, bez(ix), scatter_cdata(scatter_GENERATOR(GENidx,1)), &
                 theta, xi, rndPhi(j)
        end do
    end do

    call recuut(scatter_seed1,scatter_seed2)
    call recuin(tmpSeed1,tmpSeed2)

end subroutine

double precision function scatter_profile_getDensity(profileIdx, x,y) result(retval)

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

    integer, intent(in) :: profileIdx
    double precision, intent(in) :: x,y

    select case (scatter_PROFILE(profileIdx,2))
    case (1)  ! FLAT
        retval = scatter_fdata(scatter_PROFILE(profileIdx,3))
    case (10) ! GAUSS1
        ! TODO
    case default
        write(lout,*) "SCATTER> ERROR in scatter_profile_getDensity"
        write(lout,*) "Type", scatter_PROFILE(profileIdx,2), &
                    & "for profile '"// trim(stringzerotrim( &
                    & scatter_cdata(scatter_PROFILE(profileIdx,1)) &
                    & ))//"' not understood."
        call prror(-1)
    end select

end function

subroutine scatter_profile_getParticle(profileIdx, x,y, xp,yp,E)

    implicit none
    integer, intent(in) :: profileIdx
    double precision, intent(in) :: x,y
    double precision, intent(out) :: xp,yp,E

    ! Return a particle to collide with

end subroutine

double precision function scatter_generator_getCrossSection(profileIDX, generatorIDX, x,y, xp,yp, E)

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

    integer, intent(in) :: profileIDX, generatorIDX
    double precision, intent(in) :: x,y,xp,yp,E

    ! Temp variables
    double precision xp_target, yp_target, E_target

    ! Calculate S
    call scatter_profile_getParticle(profileIDX, x,y, xp_target,yp_target,E_target)

    ! Calculate the crossection as function of S
    select case (scatter_GENERATOR(generatorIDX,2))
    case (1)  ! ABSORBER
        !...
    case (10) ! PPBEAMELASTIC
        scatter_generator_getCrossSection = 30d-27
    case default
        write(lout,*) "SCATTER> ERROR in scatter_generator_getCrossSection"
        write(lout,*) "Type", scatter_PROFILE(profileIdx,2), &
                    & "for profile '"// trim(stringzerotrim( &
                    & scatter_cdata(scatter_PROFILE(profileIdx,1)) &
                    & ))//"' not understood."
        call prror(-1)
    end select

end function

subroutine scatter_generator_getTandXi(generatorIDX, t, xi)

    implicit none

+ca crcoall

    ! Could be affected by S as well?
    
    double precision scatter_generator_getPPElastic

    integer, intent(in) :: generatorIDX
    double precision, intent(out) :: t, xi

    select case(generatorIDX)
    case (1)  ! ABSORBER
        !...
    case (10) ! PPBEAMELASTIC
        t  = scatter_generator_getPPElastic(0.046d0,18.52d0,4.601d0,2.647d0,0.0d0)
        xi = 0d0
    case default
        write(lout,*) "SCATTER> ERROR in scatter_generator_getTandXi"
        write(lout,*) "Type", generatorIDX, "not understood"
        call prror(-1)
    end select

end subroutine

double precision function scatter_generator_getPPElastic(a, b1, b2, phi, tmin) result(t)

    implicit none

    ! Input
    double precision, intent(in) :: a, b1, b2, phi, tmin

    ! Temp Variables
    double precision g1, g2, g3, gg, slope, invB1, invB2, rndArr(3)

    g1    =        exp(-b1*tmin)/b1
    g3    = a**2 * exp(-b2*tmin)/b2
    slope = g3/(g1+g3)
    invB1 = 1.0d0/b1
    invB2 = 1.0d0/b2

    do
        call ranecu(rndArr, 3, -1)

        if(rndArr(1) .gt. slope) then
            t = tmin - invB1*log(rndArr(2))
        else
            t = tmin - invB2*log(rndArr(2))
        end if

        g1 =        exp(-b1*t)
        g2 =  2*a * exp(-0.5d0*(b1+b2)*t) * cos(phi)
        g3 = a**2 * exp(-b2*t)
        gg = (g1+g2+g3)/(g1+g3)

        if(rndArr(3) .lt. gg) exit
    end do

end function
