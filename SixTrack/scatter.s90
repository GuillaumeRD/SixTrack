+dk scatter
! Deck for the scattering routines implemented in the SCATTER block

subroutine scatter_initialize

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

    logical lopen

    ! Open scatter_log.txt
    inquire( unit=667, opened=lopen )
    if (lopen) then
        write(lout,*) "ERROR in SCATTER when opening scatter_log.txt"
        write(lout,*) "Unit 667 was already taken."
        call prror(-1)
    end if

    open(667,file="scatter_log.txt",status="replace",form="formatted")
    write(667,"(A)") "# scatter_log"
    write(667,"(A)") "# ID turn bez scatter_GENERATOR t[MeV^2] xi theta[mrad] phi[rad] prob"

end subroutine scatter_initialize

subroutine scatter_dumpdata

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

    integer ii,jj

    write(lout,'(a)') "*** BEGIN SCATTER DUMP ***"

    write(lout,'(a)') "Options:"
    write(lout,*)     "scatter_active =", scatter_active
    write(lout,*)     "scatter_debug  =", scatter_debug
    write(lout,*)     "Seeds          =", scatter_seed1, ";", scatter_seed2

    write(lout,'(a)') "Arrays:"

    write(lout,*) "scatter_ELEM: (",scatter_nELEM,",",scatter_maxGenELEM,"):"
    do ii=1, scatter_nELEM
        write(lout,*) ii, ":", scatter_ELEM(ii,:)
    end do

    write(lout,*) "scatter_ELEM_scale: (",scatter_nELEM,"):"
    do ii=1, scatter_nELEM
        write(lout,*) ii, ":", scatter_ELEM_scale(ii)
    end do

    write(lout,*) "scatter_PROFILE: (", scatter_nPROFILE,",",5,"):"
    do ii=1, scatter_nPROFILE
        write(lout,*) ii, ":", scatter_PROFILE(ii,:)
    end do

    write(lout,*) "scatter_GENERATOR: (",scatter_nGENERATOR,",",5,"):"
    do ii=1, scatter_nGENERATOR
        write(lout,*) ii, ":", scatter_GENERATOR(ii,:)
    end do

    write(lout,*) "scatter_idata: (",scatter_nidata,"):"
    do ii=1, scatter_nidata
        write(lout,*) ii, ":", scatter_idata(ii)
    end do

    write(lout,*) "scatter_fdata: (",scatter_nfdata,"):"
    do ii=1, scatter_nfdata
        write(lout,*) ii, ":", scatter_fdata(ii)
    end do

    write(lout,*) "scatter_cdata: (",scatter_ncdata,"):"
    do ii=1, scatter_ncdata
        write(lout,*) ii, ": '"//trim(stringzerotrim(scatter_cdata(ii)))//"'"
    end do

    write(lout,'(a)') "**** END SCATTER DUMP ****"

end subroutine

!---------------------------------------------------------------------------------------------------
! BEGIN Input Parser Functions
!---------------------------------------------------------------------------------------------------

! ***** PARSE SCATTER ELEM SUBROUTINE *****
subroutine scatter_parseElem(getfields_fields,getfields_lfields,getfields_nfields)

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

+ca common
+ca commonmn

    ! Temporary Variables
    integer ii, j
+if crlibm
    integer errno
    double precision round_near
+ei

    ! Check number of arguments
    if(getfields_nfields .lt. 5) then
        write(lout,'(a)') "SCATTER> ERROR, ELEM expected at least 5 arguments:"
        write(lout,'(a)') "ELEM elemname profile scaling gen1 (gen2...)"
        call prror(-1)
    end if

    ! Add the element to the list
    scatter_nELEM = scatter_nELEM + 1
    if (scatter_nELEM .gt. scatter_maxELEM ) then
        write(lout,'(a,i4,a)') "SCATTER> ERROR, max elements = ",scatter_maxELEM," exceeded."
        call prror(-1)
    end if

    ! Find the single element referenced
    ii = -1
    do j=1,il
        if(bez(j) .eq. getfields_fields(2)(1:getfields_lfields(2))) then
            if (ii.ne.-1) then
                write(lout,'(a)') "SCATTER> ERROR, found element '"// &
                                  getfields_fields(2)(1:getfields_lfields(2))// &
                                  "' twice in SINGLE ELEMENTS list."
                call prror(-1)
            end if
            ii = j

            if (scatter_elemPointer(j).ne.0) then
                write(lout,'(a)') "SCATTER> ERROR, tried to define element '"// &
                                  getfields_fields(2)(1:getfields_lfields(2))// &
                                  "' twice."
                call prror(-1)
            end if

            scatter_elemPointer(j) = scatter_nELEM
            scatter_ELEM(scatter_nELEM,1) = j
        end if
    end do

    if (scatter_ELEM(scatter_nELEM,1).eq.0) then
        write(lout,*) "SCATTER> ERROR: Could not find element '"// &
                      getfields_fields(2)(1:getfields_lfields(2)) // "'"
        call prror(-1)
    end if

    ! Find the profile name referenced
    do j=1,scatter_nPROFILE
        if( trim(stringzerotrim(scatter_cdata(scatter_PROFILE(j,1)))) &
                .eq. getfields_fields(3)(1:getfields_lfields(3)) ) then
            scatter_ELEM(scatter_nELEM,2) = j
        end if
    end do

    if (scatter_ELEM(scatter_nELEM,2).eq.0) then
        write(lout,*) "SCATTER> ERROR: Could not find profile '"// &
                      getfields_fields(3)(1:getfields_lfields(3)) // "'"
        call prror(-1)
    end if

    ! Store the scaling
+if crlibm
    scatter_ELEM_scale(scatter_nELEM) = round_near(errno,getfields_lfields(4)+1,getfields_fields(4))
    if(errno .ne. 0) call rounderr(errno,getfields_fields,4,scatter_ELEM_scale(scatter_nELEM))
+ei
+if .not.crlibm
    read(getfields_fields(4)(1:getfields_lfields(4)),*) scatter_ELEM_scale(scatter_nELEM)
+ei

    ! Find the generator(s) referenced
    if (getfields_nfields-4 .gt. scatter_maxGenELEM-2) then
        write(lout,*) "SCATTER> ERROR when parsing ELEM,", &
                      getfields_nfields-4, "generators specified, space for", &
                      scatter_maxGenELEM-2
        call prror(-1)
    end if

    do ii=5,getfields_nfields
        !In general inside this loop:
        ! Take care of offsets in getfields_field (-4) and scatter_ELEM (+2)
        ! such that ii=5 -> column 3 of scatter_ELEM, ii=6 -> column 4, etc.
        !
        ! A dummy variable might not be a bad idea here ...

        !In case we won't find the generator name
        scatter_ELEM(scatter_nELEM,ii-4+2) = -1

        ! Search for the generator with the right name
        do j=1, scatter_nGENERATOR
            if( trim(stringzerotrim(scatter_cdata(scatter_GENERATOR(j,1)))) &
                .eq. getfields_fields(ii)(1:getfields_lfields(ii)) ) then
                ! Found it
                scatter_ELEM(scatter_nELEM,ii-4+2) = j
            end if
        end do

        !If it is still -1, it wasn't found
        if(scatter_ELEM(scatter_nELEM,ii-4+2) .eq. -1) then
            write(lout,*) "SCATTER> ERROR when parsing ELEM, generator '"// &
                          getfields_fields(ii)(1:getfields_lfields(ii))// &
                          "' not found."
            call prror(-1)
        end if

        !Loop over those GENerators we've filled before
        ! (i.e. up to but not including column ii-4+2)
        ! to check for duplicates
        do j=3, ii-4+2-1
            if(scatter_ELEM(scatter_nELEM,j) .eq. scatter_ELEM(scatter_nELEM,ii-4+2)) then
                write(lout,*) "SCATTER> ERROR when parsing ELEM, generator '"// &
                              getfields_fields(ii)(1:getfields_lfields(ii)) // &
                              "' used twice."
                call prror(-1)
            end if
        end do
    end do

end subroutine

! ***** PARSE SCATTER PRO SUBROUTINE *****
subroutine scatter_parseProfile(getfields_fields,getfields_lfields,getfields_nfields)

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

    ! Temporary Variables
    integer ii, tmpIdx
+if crlibm
    integer errno
    double precision round_near
+ei

    ! Check number of arguments
    if(getfields_nfields .lt. 3) then
        write(lout,'(a)') "SCATTER> ERROR, PRO expected at least 3 arguments:"
        write(lout,'(a)') "PRO name type (arguments...)"
        call prror(-1)
    end if

    ! Add a profile to the list
    scatter_nPROFILE = scatter_nPROFILE + 1
    if (scatter_nPROFILE .gt. scatter_maxPROFILE ) then
        write(lout,'(a,i4,a)') "SCATTER> ERROR, max profiles = ",scatter_maxPROFILE," exceeded."
        call prror(-1)
    endif

    ! Store the profile name
    scatter_ncdata = scatter_ncdata + 1
    if (scatter_ncdata .gt. scatter_maxdata ) then
        write(lout,'(a,i4,a)') "SCATTER> ERROR, scatter_maxdata = ",scatter_maxdata," exceeded for scatter_ncdata"
        call prror(-1)
    endif
    scatter_cdata(scatter_ncdata)(1:getfields_lfields(2)) = getfields_fields(2)(1:getfields_lfields(2))
    scatter_PROFILE(scatter_nPROFILE,1)                   = scatter_ncdata

    ! Check that the profile name is unique
    do ii=1,scatter_nPROFILE-1
        if(trim(stringzerotrim(scatter_cdata(scatter_PROFILE(ii,1)) )) &
            .eq. getfields_fields(2)(1:getfields_lfields(2)) ) then
            
            write(lout,'(a)') "SCATTER> ERROR, profile name '"// &
                              getfields_fields(2)(1:getfields_lfields(2))// &
                              "' is not unique."
            call prror(-1)
        end if
    end do

    ! Profile type dependent code
    select case (getfields_fields(3)(1:getfields_lfields(3)))
    case("FLAT")
        scatter_PROFILE(scatter_nPROFILE,2) = 1 !Integer code for FLAT
        if(getfields_nfields .ne. 6) then
            write(lout,'(a)') "SCATTER> ERROR, PRO expected 6 arguments:"
            write(lout,'(a)') "PRO name type density[targets/cm^2] mass[MeV/c^2] momentum[MeV/c]"
            call prror(-1)
        end if

        ! Request space to store the density
        tmpIdx = scatter_nfdata + 1
        scatter_PROFILE(scatter_nPROFILE,3) = tmpIdx
        scatter_nfdata = scatter_nfdata + 3
        if(scatter_nfdata .gt. scatter_maxdata) then
            write(lout,'(a,i4,a)') "SCATTER> ERROR, maxdata = ",scatter_maxdata," exceeded for floats."
            call prror(-1)
        end if

+if crlibm
        ! Density
        scatter_fdata(tmpIdx) = round_near(errno,getfields_lfields(4)+1,getfields_fields(4))
        if(errno .ne. 0) call rounderr(errno,getfields_fields,4,scatter_fdata(tmpIdx))

        ! Mass
        scatter_fdata(tmpIdx+1) = round_near(errno,getfields_lfields(5)+1,getfields_fields(5))
        if(errno .ne. 0) call rounderr(errno,getfields_fields,5,scatter_fdata(tmpIdx+1))

        ! Momentum
        scatter_fdata(tmpIdx+2) = round_near(errno,getfields_lfields(6)+1,getfields_fields(6))
        if(errno .ne. 0) call rounderr(errno,getfields_fields,6,scatter_fdata(tmpIdx+2))
+ei
+if .not.crlibm
        ! Density
        read(getfields_fields(4)(1:getfields_lfields(4)),*) scatter_fdata(tmpIdx)

        ! Mass
        read(getfields_fields(5)(1:getfields_lfields(5)),*) scatter_fdata(tmpIdx+1)

        ! Momentum
        read(getfields_fields(6)(1:getfields_lfields(6)),*) scatter_fdata(tmpIdx+2)
+ei

    case("GAUSS1")
        scatter_PROFILE(scatter_nPROFILE,2) = 10  !Integer code for BEAM_GAUSS1
        !TODO: Read sigma x,y, density

    case default
        write(lout,'(a)') "SCATTER> ERROR, PRO name '"// &
                          getfields_fields(3)(1:getfields_lfields(3))// &
                          "' not recognized."
        call prror(-1)

    end select

end subroutine

! ***** PARSE SCATTER GEN SUBROUTINE *****
subroutine scatter_parseGenerator(getfields_fields,getfields_lfields,getfields_nfields)

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

+ca parnum

    ! Temporary Variables
    integer ii, tmpIdx
+if crlibm
    integer errno
    double precision round_near
+ei

    ! Check number of arguments
    if(getfields_nfields .lt. 3) then
        write(lout,'(a)') "SCATTER> ERROR, GEN expected at least 3 arguments:"
        write(lout,'(a)') "GEN name type (arguments...)"
        call prror(-1)
    end if

    ! Add a generator to the list
    scatter_nGENERATOR = scatter_nGENERATOR + 1
    if(scatter_nGENERATOR .gt. scatter_maxGENERATOR) then
        write(lout,'(a,i4,a)') "SCATTER> ERROR, max generators = ",scatter_maxGENERATOR," exceeded."
        call prror(-1)
    end if

    ! Store the generator name
    scatter_ncdata = scatter_ncdata + 1
    if(scatter_ncdata .gt. scatter_maxdata) then
        write(lout,'(a,i4,a)') "SCATTER> ERROR, scatter_maxdata = ",scatter_maxdata," exceeded for scatter_ncdata"
        call prror(-1)
    end if
    scatter_cdata(scatter_ncdata)(1:getfields_lfields(2)) = getfields_fields(2)(1:getfields_lfields(2))
    scatter_GENERATOR(scatter_nGENERATOR,1) = scatter_ncdata

    ! Check that the generator name is unique
    do ii=1,scatter_nGENERATOR-1
        if (trim(stringzerotrim(scatter_cdata(scatter_GENERATOR(ii,1)) )) &
            .eq. getfields_fields(2)(1:getfields_lfields(2)) ) then
            write(lout,'(a)') "SCATTER> ERROR, generator name '"// &
                              getfields_fields(2)(1:getfields_lfields(2))// &
                              "' is not unique."
            call prror(-1)
       end if
    end do

    ! Generator type-dependent code
    select case (getfields_fields(3)(1:getfields_lfields(3)))
    case("ABSORBER")

        scatter_GENERATOR(scatter_nGENERATOR,2) = 1  ! Code for ABSORBER

    case("PPBEAMELASTIC")

        scatter_GENERATOR(scatter_nGENERATOR,2) = 10 ! Code for PPBEAMELASTIC
        if(getfields_nfields .lt. 8 .or. getfields_nfields .gt. 9) then
            write(lout,'(a)') "SCATTER> ERROR, GEN PPBEAMELASTIC expected 8 or 9 arguments:"
            write(lout,'(a)') "GEN name PPBEAMELASTIC a b1 b2 phi tmin (crossSection)"
            call prror(-1)
        end if

        ! Request space to store the arguments
        tmpIdx = scatter_nfdata + 1
        scatter_GENERATOR(scatter_nGENERATOR,3) = tmpIdx
        scatter_GENERATOR(scatter_nGENERATOR,4) = 0      ! Index of scatter input, if present
        scatter_nfdata = scatter_nfdata + getfields_nfields - 3
        if(scatter_nfdata .gt. scatter_maxdata) then
            write(lout,'(a,i4,a)') "SCATTER> ERROR, maxdata = ",scatter_maxdata," exceeded for floats."
            call prror(-1)
        end if

+if crlibm
        ! PPBEAMELASTIC a
        scatter_fdata(tmpIdx)   = round_near(errno,getfields_lfields(4)+1,getfields_fields(4))
        if(errno .ne. 0) call rounderr(errno,getfields_fields,4,scatter_fdata(tmpIdx))

        ! PPBEAMELASTIC b1
        scatter_fdata(tmpIdx+1) = round_near(errno,getfields_lfields(5)+1,getfields_fields(5))
        if(errno .ne. 0) call rounderr(errno,getfields_fields,5,scatter_fdata(tmpIdx+1))

        ! PPBEAMELASTIC b2
        scatter_fdata(tmpIdx+2) = round_near(errno,getfields_lfields(6)+1,getfields_fields(6))
        if(errno .ne. 0) call rounderr(errno,getfields_fields,6,scatter_fdata(tmpIdx+2))

        ! PPBEAMELASTIC phi
        scatter_fdata(tmpIdx+3) = round_near(errno,getfields_lfields(7)+1,getfields_fields(7))
        if(errno .ne. 0) call rounderr(errno,getfields_fields,7,scatter_fdata(tmpIdx+3))

        ! PPBEAMELASTIC b2
        scatter_fdata(tmpIdx+4) = round_near(errno,getfields_lfields(8)+1,getfields_fields(8))
        if(errno .ne. 0) call rounderr(errno,getfields_fields,8,scatter_fdata(tmpIdx+4))

        if(getfields_nfields .eq. 9) then
            ! PPBEAMELASTIC crossSection
            scatter_fdata(tmpIdx+5) = round_near(errno,getfields_lfields(9)+1,getfields_fields(9))
            if(errno .ne. 0) call rounderr(errno,getfields_fields,9,scatter_fdata(tmpIdx+5))
            scatter_GENERATOR(scatter_nGENERATOR,4) = tmpIdx+5
        end if
+ei
+if .not.crlibm
        ! PPBEAMELASTIC a
        read(getfields_fields(4)(1:getfields_lfields(4)),*) scatter_fdata(tmpIdx)

        ! PPBEAMELASTIC b1
        read(getfields_fields(5)(1:getfields_lfields(5)),*) scatter_fdata(tmpIdx+1)

        ! PPBEAMELASTIC b2
        read(getfields_fields(6)(1:getfields_lfields(6)),*) scatter_fdata(tmpIdx+2)

        ! PPBEAMELASTIC phi
        read(getfields_fields(7)(1:getfields_lfields(7)),*) scatter_fdata(tmpIdx+3)

        ! PPBEAMELASTIC tmin
        read(getfields_fields(8)(1:getfields_lfields(8)),*) scatter_fdata(tmpIdx+4)

        if(getfields_nfields .eq. 9) then
            ! PPBEAMELASTIC crossSection
            read(getfields_fields(9)(1:getfields_lfields(9)),*) scatter_fdata(tmpIdx+5)
            scatter_GENERATOR(scatter_nGENERATOR,4) = tmpIdx+5
        end if
+ei

        ! Check sanity of input values
        if(scatter_fdata(tmpIdx+1) .lt. pieni) then
            write(lout,'(a)') "SCATTER> ERROR, GEN PPBEAMELASTIC 5th input (b1) must be larger than zero"
            call prror(-1)
        end if
        if(scatter_fdata(tmpIdx+2) .lt. pieni) then
            write(lout,'(a)') "SCATTER> ERROR, GEN PPBEAMELASTIC 6th input (b2) must be larger than zero"
            call prror(-1)
        end if

    case default

        write(lout,'(a)') "SCATTER> ERROR, GEN name '"// &
                          getfields_fields(3)(1:getfields_lfields(3))// &
                          "' not recognized."
        call prror(-1)

    end select

end subroutine

! ***** PARSE SCATTER SEED SUBROUTINE *****
subroutine scatter_parseSeed(getfields_fields,getfields_lfields,getfields_nfields)

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

    ! Check the number of arguments
    if(getfields_nfields .ne. 3) then
        write(lout,'(a)') "SCATTER> ERROR, SEED expected 2 arguments:"
        write(lout,'(a)') "GEN seed1 seed2"
        call prror(-1)
    end if

    ! Read the seeds
    read(getfields_fields(2)(1:getfields_lfields(2)),*) scatter_seed1
    read(getfields_fields(3)(1:getfields_lfields(3)),*) scatter_seed2

end subroutine scatter_parseSeed

!---------------------------------------------------------------------------------------------------
! END Input Parser Functions
!---------------------------------------------------------------------------------------------------

subroutine scatter_thin(ix, turn)

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

+ca common
+ca commonmn
+ca parnum

    ! Define functions
    double precision scatter_profile_getDensity
    double precision scatter_generator_getCrossSection
    double precision scatter_generator_getPPElastic

    ! Temp variables
    integer          ELEMidx, PROidx, GENidx
    integer          i, j
    integer          tmpSeed1, tmpSeed2
    double precision s, t, xi, theta
    double precision crossSection, N, P
    double precision rndPhi(npart), rndP(npart)
    double precision scaling

    integer, intent(in) :: ix, turn

    ELEMidx = scatter_elemPointer(ix)
    PROidx  = scatter_ELEM(ELEMidx,2)
    scaling = scatter_ELEM_scale(ELEMidx)

    if (scatter_debug) then
        write(lout,*) "SCATTER> In scatter_thin, ix=",ix, &
                      "bez='"//trim(bez(ix))//"' napx=",napx, "turn=",turn, &
                      "scaling=",scaling
    endif

    if (scaling.le.pieni) then
       !Skip the whole thing if the scaling is zero
       return
    endif

    !Compute the "standard" s (used for cross sections)
    !(ask profile for the p)

    call recuut(tmpSeed1,tmpSeed2)
    call recuin(scatter_seed1,scatter_seed2)

    ! ! Code to run a test of the distribution
    ! open(13077,file="t.txt",status="replace",form="formatted")
    ! do i=1,100000000
    !     t = scatter_generator_getPPElastic(0.046d0,18.52d0,4.601d0,2.647d0,0.0d0)
    !     write(13077,*) t
    ! end do
    ! close(13077)
    ! stop

    ! Loop over generators
    do i=3,scatter_maxGenELEM
        GENidx = scatter_ELEM(ELEMidx,i)
        if(GENidx .eq. 0) exit

        call ranecu(rndPhi, napx, -1)
        call ranecu(rndP,   napx, -1)
        rndPhi = rndPhi*2*pi

        do j=1, napx
            ! Compute the cross section at this s
            ! (in most cases roughly equal for all particles; use mean x,y,xp,yp,E)
            crossSection = scatter_generator_getCrossSection( &
                PROidx,GENidx, xv(1,j),xv(2,j),yv(1,j),yv(2,j),ejv(j) &
            )

            ! Ask profile for density at x,y
            N = scatter_profile_getDensity(PROidx,xv(1,j),xv(2,j))

            ! Compute probability P
            P = N*crossSection*scaling
            ! If RNG > P -> go to next particle, else scatter
            if (rndP(j) .gt. P) then
                cycle
            endif

            ! Ask generator for t and xi
            call scatter_generator_getTandXi(GENidx,t,xi)

            ! Use generator t and xi to update particle j;
            ! remember to update ALL the energy arrays
            theta   = 1d3*sqrt(t)/ejfv(j)                  ! Unit mrad
            yv(1,j) = theta*cos(rndPhi(j)) + yv(1,j)
            yv(2,j) = theta*sin(rndPhi(j)) + yv(2,j)

            ! Output to file
            write(667,"(2(1x,I8),2(1x,A),2(1x,F13.3),3(1x,1PE16.9))") j, turn, bez(ix), &
                trim(stringzerotrim(scatter_cdata(scatter_GENERATOR(GENidx,1)))), &
                t, xi, theta, rndPhi(j), P
        end do
    end do

    call recuut(scatter_seed1,scatter_seed2)
    call recuin(tmpSeed1,tmpSeed2)

end subroutine

double precision function scatter_profile_getDensity(profileIdx, x,y) result(retval)

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

    integer, intent(in) :: profileIdx
    double precision, intent(in) :: x, y

    select case (scatter_PROFILE(profileIdx,2))
    case (1)  ! FLAT
        retval = scatter_fdata(scatter_PROFILE(profileIdx,3))
    case (10) ! GAUSS1
        ! TODO
    case default
        write(lout,*) "SCATTER> ERROR in scatter_profile_getDensity"
        write(lout,*) "Type", scatter_PROFILE(profileIdx,2), &
                      "for profile '"// trim(stringzerotrim( &
                      scatter_cdata(scatter_PROFILE(profileIdx,1)) &
                      ))//"' not understood."
        call prror(-1)
    end select

end function

subroutine scatter_profile_getParticle(profileIdx, x,y, xp,yp,E)

    implicit none

    integer, intent(in) :: profileIdx
    double precision, intent(in) :: x,y
    double precision, intent(out) :: xp,yp,E

    ! Return a particle to collide with

end subroutine

double precision function scatter_generator_getCrossSection(profileIDX, generatorIDX, x,y, xp,yp, E)

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

    integer, intent(in) :: profileIDX, generatorIDX
    double precision, intent(in) :: x, y, xp, yp, E

    ! Temporary variables
    integer          tmpIdx
    double precision xp_target, yp_target, E_target

    ! Calculate S
    call scatter_profile_getParticle(profileIDX, x,y, xp_target,yp_target,E_target)

    ! Calculate the cross section as function of S
    select case (scatter_GENERATOR(generatorIDX,2))
    case (1)  ! ABSORBER
        !...

    case (10) ! PPBEAMELASTIC
        tmpIdx = scatter_GENERATOR(generatorIDX,4)
        if(tmpIdx .eq. 0) then
            scatter_generator_getCrossSection = 30d-27
        else
            scatter_generator_getCrossSection = scatter_fdata(tmpIdx)
        end if

    case default
        write(lout,*) "SCATTER> ERROR in scatter_generator_getCrossSection"
        write(lout,*) "Type", scatter_PROFILE(profileIdx,2), &
                      "for profile '"// trim(stringzerotrim( &
                      scatter_cdata(scatter_PROFILE(profileIdx,1)) &
                      ))//"' not understood."
        call prror(-1)

    end select

end function

subroutine scatter_generator_getTandXi(generatorIDX, t, xi)

    implicit none

+ca crcoall
+ca parpro
+ca comgetfields
+ca stringzerotrim
+ca comscatter

    double precision scatter_generator_getPPElastic

    integer, intent(in) :: generatorIDX
    double precision, intent(out) :: t, xi

    ! Temporary variables
    integer          tmpIdx
    double precision a, b1, b2, phi, tmin

    ! Could be affected by S as well?

    select case (scatter_GENERATOR(generatorIDX,2))
    case (1)  ! ABSORBER
        !...
    case (10) ! PPBEAMELASTIC

        tmpIdx = scatter_GENERATOR(generatorIDX,3)
        a      = scatter_fdata(tmpIdx)
        b1     = scatter_fdata(tmpIdx+1)
        b2     = scatter_fdata(tmpIdx+2)
        phi    = scatter_fdata(tmpIdx+3)
        tmin   = scatter_fdata(tmpIdx+4)

       !t  = scatter_generator_getPPElastic(0.046d0,18.52d0,4.601d0,2.647d0,0.0d0)
        t  = scatter_generator_getPPElastic(a, b1, b2, phi, tmin)
        xi = 0d0   ! Dummy value, for now
        t  = t*1d6 ! Scale return variable to MeV^2

    case default
        write(lout,*) "SCATTER> ERROR in scatter_generator_getTandXi"
        write(lout,*) "Type", generatorIDX, "not understood"
        call prror(-1)

    end select

end subroutine

! Based on Helmut Burkhardt's code presented on 05-04-2017
! "Elastic pp scattering estimates and simulation relevant for burn-off"
! https://indico.cern.ch/event/625576/
double precision function scatter_generator_getPPElastic(a, b1, b2, phi, tmin) result(t)

    implicit none

+ca crcoall

    double precision, intent(in) :: a, b1, b2, phi, tmin

    ! Temp Variables
    integer          nItt, maxItt
    double precision g1, g2, g3, gg, prob3, invB1, invB2, rndArr(3)

    ! Approximate distribution
    g1    =        exp(-b1*tmin)/b1 ! Soft scatter term
    g3    = a**2 * exp(-b2*tmin)/b2 ! Hard scatter term
    prob3 = g3/(g1+g3)              ! Probability of g3

    ! Pre-calculate inverses
    invB1 = 1.0d0/b1
    invB2 = 1.0d0/b2

    nItt   = 0
    maxItt = 1000000
    do
        nItt = nItt + 1
        call ranecu(rndArr, 3, -1)

        ! Randomly switch between g1 and g3 according to probability
        if(rndArr(1) .gt. prob3) then
            t = tmin - invB1*log(rndArr(2))
        else
            t = tmin - invB2*log(rndArr(2))
        end if

        ! Exact distribution
        g1 =        exp(-b1*t)                       ! Soft scatter term
        g2 =  2*a * exp(-0.5d0*(b1+b2)*t) * cos(phi) ! Interference
        g3 = a**2 * exp(-b2*t)                       ! Hard scatter term
        gg = (g1+g2+g3)/(g1+g3)

        ! Check hit/miss on exact distribution
        ! if miss, get new t value
        ! if too many attempts, exit
        if(rndArr(3) .lt. gg .or. nItt .gt. maxItt) exit
    end do

    if(nItt .gt. maxItt) then
        write(lout,*) "SCATTER> ERROR in generator PPBEAMELASTIC"
        write(lout,*) "Limit of", maxItt, "misses in generator loop reached."
        call prror(-1)
    end if

end function
