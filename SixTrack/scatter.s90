+dk scatter
! Deck for the scattering routines implemented in the SCATTER block

module scatter
  
  use floatPrecision
  use end_sixtrack
  use mathlib_bouncer
  use numerical_constants, only : zero, half, one, two, c1e3, c1e6, pieni
  use parpro ! For nele
  use mod_ranecu
  use mod_alloc
  use strings
  use string_tools
  
  implicit none
  
  ! We have to declare all this stuff, and we can't set them PRIVATE.
  ! Therefore, we always need to import the SCATTER module using "only",
  ! or else it will bring the contents of parpro, comgetfields,
  ! and stringzerotrim along with it...
  
  ! Common variables for the SCATTER routines
  logical, public, save :: scatter_active
  logical, public, save :: scatter_debug
  
  ! Pointer from an element back to a ELEM statement (0 => not used)
  integer, allocatable :: scatter_elemPointer(:) !(nele)
  
  ! Configuration for an ELEM, columns are:
  ! (1)   : pointer to the SingleElement
  ! (2)   : pointer to PROFILE
  ! (3-5) : pointer to GENERATORs
  integer,          allocatable, public, save :: scatter_ELEM(:,:)
  real(kind=fPrec), allocatable, public, save :: scatter_ELEM_scale(:)
  
  ! Configuration for PROFILE
  ! Columns of scatter_PROFILE:
  ! (1)   : Profile name in fort.3 (points within scatter_cexpr)
  ! (2)   : Profile type
  ! (3-5) : Arguments (often pointing within scatter_{i|c|f}expr)
  integer, allocatable, public, save :: scatter_PROFILE(:,:)
  
  ! Configuration for GENERATOR
  ! (1)   : Generator name in fort.3 (points within scatter_cexpr)
  ! (2)   : Generator type
  ! (3-5) : Arguments (often pointing within scatter_{i|c|f}expr)
  integer, allocatable, public, save  :: scatter_GENERATOR(:,:)
  
    ! General data storage ala DYNK
    integer scatter_maxdata, scatter_maxstrlen
    parameter (scatter_maxdata   = 5000,                              &
               scatter_maxstrlen = stringzerotrim_maxlen )

    integer,                       allocatable :: scatter_idata (:)
    real(kind=fPrec),              allocatable :: scatter_fdata (:)
    character (scatter_maxstrlen), allocatable :: scatter_cdata (:)
    
    ! Number of currently used positions in arrays
    integer :: scatter_nELEM, scatter_nPROFILE, scatter_nGENERATOR
    integer :: scatter_nidata, scatter_nfdata, scatter_ncdata
    
    integer :: scatter_seed1, scatter_seed2
    
    
    ! Variable for file units
    integer :: scatter_logFile

    !Declare which variables should be statically stored;
    ! TODO: Consider putting the SAVE keyword direcly into
    ! the variable declarations instead.
    save scatter_elemPointer,          &
         scatter_idata, scatter_fdata, scatter_cdata,                   &
         scatter_nELEM, scatter_nPROFILE, scatter_nGENERATOR,           &
         scatter_nidata, scatter_nfdata, scatter_ncdata,                &
         scatter_seed1, scatter_seed2,   &
         scatter_logFile

#ifdef CR
    integer :: scatter_filepos,scatter_filepos_cr
    integer,                      allocatable :: scatter_idata_cr (:)
    real(kind=fPrec),             allocatable :: scatter_fdata_cr (:)
    character(scatter_maxstrlen), allocatable :: scatter_cdata_cr (:)
    integer :: scatter_nidata_cr, scatter_nfdata_cr, scatter_ncdata_cr
    integer :: scatter_seed1_cr, scatter_seed2_cr
    
    save scatter_filepos,scatter_filepos_cr, &
         scatter_idata_cr, scatter_fdata_cr, scatter_cdata_cr, &
         scatter_nidata_cr,scatter_nfdata_cr, scatter_ncdata_cr, &
         scatter_seed1_cr, scatter_seed2_cr
#endif

! ================================================================================================ !
!  HERE COMES THE SUBROUTINES
! ================================================================================================ !
contains

!Used for the very initial allocation of arrays that scale with global parameters like NELE
subroutine scatter_allocate_arrays

  use crcoall
  use end_sixtrack
  
  implicit none
  
!   integer stat
  
!  allocate(scatter_elemPointer(nele), STAT=stat)
!
!  if (stat.ne.0) then
!    write(lout,"(A,I8)") "ERROR in SUBROUTINE SCATTER_ALLOCATE_ARRAYS; stat=", stat
!    call prror(-1)
!  endif

  call alloc(scatter_elemPointer, nele, 0,    "scatter_elemPointer")
  call alloc(scatter_ELEM,        1,5,  0,    "scatter_ELEM")
  call alloc(scatter_ELEM_scale,  1,    zero, "scatter_ELEM_scale")
  call alloc(scatter_PROFILE,     1,5,  0,    "scatter_PROFILE")
  call alloc(scatter_GENERATOR,   1,5,  0,    "scatter_GENERATOR")

end subroutine scatter_allocate_arrays

! Used changing the allocation of arrays that scale with global parameters like NELE
subroutine scatter_expand_arrays(nele_new)
  
  use crcoall
  implicit none
  integer, intent(in) :: nele_new

  call resize(scatter_elemPointer,nele_new,0,"scatter_elemPointer")
  
end subroutine scatter_expand_arrays
  
! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 02-11-2017
! =================================================================================================
subroutine scatter_allocate
    
  use crcoall
  use parpro
  
  implicit none
  
  integer stat
  integer i,j
    
    write(lout,"(A,I8)") "SCATTER_ALLOCATE : scatter_maxdata=",scatter_maxdata
    allocate( scatter_idata(scatter_maxdata), &
              scatter_fdata(scatter_maxdata), &
              scatter_cdata(scatter_maxdata), &
              STAT=stat)

    if (stat.ne.0) then
        write(lout,"(A,I8)") "ERROR in SCATTER_ALLOCATE(); stat=",stat
        call prror(-1)
    end if
    
#ifdef CR
    write(lout,"(A,I8)") "SCATTER_ALLOCATE [CR] : scatter_maxdata=",scatter_maxdata
    allocate( scatter_idata_cr(scatter_maxdata), &
              scatter_fdata_cr(scatter_maxdata), &
              scatter_cdata_cr(scatter_maxdata), &
              STAT=stat )
    
    if (stat.ne.0) then
       write(lout,"(A,I8)") "ERROR in SCATTER_ALLOCATE [CR]; stat=",stat
       call prror(-1)
    end if
#endif
end subroutine scatter_allocate

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last Modified: 2018-04-16
! =================================================================================================
subroutine scatter_initialise
  
  use crcoall
  use parpro
  use file_units
#ifdef HDF5
  ! use hdf5
  use hdf5_output
#endif
  
  implicit none
  
  integer ierro
  logical lopen
  
#ifdef HDF5
  if(h5_useForSCAT) then
    call h5_initForScatter()
    ! h5dcreate_f(h5_scattID, "scatter_log", type_id, space_id, dset_id, hdferr)
  else
#endif
    ! Get a file unit number
    call funit_requestUnit("scatter_log.dat",scatter_logFile)

    ! Open scatter_log.dat
#ifdef CR
    ! Could have loaded a CR just before the start of the tracking;
    ! in this case the scatter_log.dat is already open and positioned,
    ! so don't try to open the file again.
    if(scatter_filepos .eq. -1) then
      write(93,"(a)") "SCATTER> scatter_initialise opening new file scatter_log.dat"
#endif
      inquire(unit=scatter_logFile, opened=lopen)
      if(lopen) then
        write(lout,*) "ERROR in SCATTER when opening scatter_log.dat"
        write(lout,*) "Unit ",scatter_logFile," was already taken."
        call prror(-1)
      end if
      
      open(scatter_logFile,file="scatter_log.dat",status="replace",form="formatted")
      write(scatter_logFile,"(A)") "# scatter_log"
      write(scatter_logFile,"(A)") "# ID turn bez scatter_GENERATOR t[MeV^2] xi theta[mrad] phi[rad] prob"

#ifdef CR
      scatter_filepos = 2
      endfile(scatter_logFile,iostat=ierro)
      backspace(scatter_logFile,iostat=ierro)
    else
      write(93,"(a)") "SCATTER> scatter_initialise kept already opened file scatter_log.dat"
    end if !scatter_filepos .eq. -1
#endif
#ifdef HDF5
  end if ! h5_useForSCAT
#endif
  
end subroutine scatter_initialise

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last Modified: 2018-04-20
! =================================================================================================
subroutine scatter_closeUnits
  
#ifdef HDF5
  use hdf5_output
#endif

  implicit none
  
  logical lopen
  
#ifdef HDF5
  if(h5_useForSCAT) then
    !call h5_closeForScatter()
  else
#endif
    if (scatter_active) then
      inquire(unit=scatter_logFile, opened=lopen)
      if(lopen) close(scatter_logFile)
    end if
#ifdef HDF5
  end if
#endif
  
end subroutine scatter_closeUnits

! =================================================================================================
!  K. Sjobak, BE-ABP-LAT and V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 11-2017
!  Called from COMNUL; initialises the arrays used by SCATTER.
! =================================================================================================
subroutine scatter_comnul
  
    implicit none
    
    integer i,j
    
    scatter_debug = .false.
    scatter_nidata = 0
    scatter_nfdata = 0
    scatter_ncdata = 0
    scatter_nELEM  = 0
    scatter_nPROFILE = 0
    scatter_nGENERATOR  = 0
    
    ! do i=1,nele
    !     scatter_elemPointer(i) = 0
    ! end do
    
    ! do i=1,scatter_maxELEM
    !     do j=1,scatter_maxGenELEM
    !         scatter_ELEM(i,j) = 0
    !     end do
    !     scatter_ELEM_scale(i) = zero
    ! end do
    
    ! do i=1,scatter_maxPROFILE
    !     scatter_PROFILE(i,1)=0
    !     scatter_PROFILE(i,2)=0
    !     scatter_PROFILE(i,3)=0
    !     scatter_PROFILE(i,4)=0
    !     scatter_PROFILE(i,5)=0
    ! end do
    
    ! do i=1,scatter_maxGENERATOR
    !     scatter_GENERATOR(i,1)=0
    !     scatter_GENERATOR(i,2)=0
    !     scatter_GENERATOR(i,3)=0
    !     scatter_GENERATOR(i,4)=0
    !     scatter_GENERATOR(i,5)=0
    ! end do

    scatter_seed1 = -1
    scatter_seed2 = -1

#ifdef CR
    scatter_filepos = -1
#endif
end subroutine scatter_comnul

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 09-2017
!  Called from CRCHECK; reads the _cr arrays for scatter from file-
!  Sets readerr=.true. if something goes wrong while reading.
! =================================================================================================
#ifdef CR
subroutine scatter_crcheck_readdata(fileunit,readerr)
    
    use crcoall
    
    implicit none
    
    integer, intent(in)  :: fileunit
    logical, intent(out) :: readerr
    
    integer j
    
    read(fileunit,err=1,end=1) &
         scatter_filepos_cr, &
         scatter_seed1_cr, scatter_seed2_cr, &
         scatter_nidata_cr, scatter_nfdata_cr, scatter_ncdata_cr, &
         (scatter_idata_cr(j), j=1,scatter_maxdata), &
         (scatter_fdata_cr(j), j=1,scatter_maxdata), &
         (scatter_cdata_cr(j), j=1,scatter_maxdata)
    
    readerr=.false.
    return
    
1   continue
    write(lout,*) "READERR in scatter_crcheck; fileunit=",fileunit
    write(93,*)   "READERR in scatter_crcheck; fileunit=",fileunit
    readerr=.true.
    
end subroutine scatter_crcheck_readdata

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 09-2017
!  Called from CRCHECK; resets the position of scatter_log.dat
! =================================================================================================
subroutine scatter_crcheck_positionFiles
    
    use crcoall
    
    implicit none

    logical lopen
    integer ierro
#ifdef BOINC
    character(len=256) filename
#endif
    integer j
    character(len=1024) arecord
    
    inquire(unit=scatter_logFile, opened=lopen)
    if(lopen) then
        write(93,"(a)") "SIXTRACR CRCHECK FAILED while repsositioning scatter_log.dat"
        write(93,"(a)") "UNIT ",scatter_logFile," already in use!"
        
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        
        write(lout,*) "SIXTRACR CRCHECK failure positioning scatter_log.dat"
        call prror(-1)
    end if
    
    if(scatter_filepos_cr .ne. -1) then
#ifdef BOINC
        call boincrf("scatter_log.dat",filename)
        open(unit=scatter_logFile,file=filename,status="old",action="readwrite", err=1)
#else
        open(unit=scatter_logFile,file="scatter_log.dat",status="old",action="readwrite", err=1)
#endif
        scatter_filepos=0
        do j=1, scatter_filepos_cr
            read(scatter_logFile,"(a1024)",end=1,err=1,iostat=ierro) arecord
            scatter_filepos = scatter_filepos+1
        end do

        ! Truncate the file after scatter_filepos_cr lines
        endfile(scatter_logFile,iostat=ierro)
        close(scatter_logFile)

#ifdef BOINC
        call boincrf("scatter_log.dat",filename)
        open(unit=scatter_logFile,file=filename,status="old",position="append",action="write", err=1)
#else
        open(unit=scatter_logFile,file="scatter_log.dat",status="old",position="append",action="write", err=1)
#endif
        write(97,*) "SIXTRACR CRCHECK sucessfully repositioned scatter_log.dat, "// &
                    "scatter_filepos=",scatter_filepos, "scatter_filepos_cr=",scatter_filepos_cr
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)

    else
        write(93,*) "SIXTRACR CRCHECK did not attempt repositioning "// &
                    "of scatter_log.dat, scatter_filepos_cr=",scatter_filepos_cr
        write(93,*) "If anything has been written to the file, "// &
                    "it will be correctly truncated in scatter_initialise."
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
    end if
    
    return ! All was well
    
1   continue
    write(93,*) "SIXTRACR CRCHECK *** ERROR *** reading scatter_log.dat, iostat=",ierro
    write(93,*) "scatter_filepos=",scatter_filepos," scatter_filepos_cr=",scatter_filepos_cr
    endfile   (93,iostat=ierro)
    backspace (93,iostat=ierro)
    write(lout,*)"SIXTRACR CRCHECK failure positioning scatter_log.dat"
    
    call prror(-1)
    
end subroutine scatter_crcheck_positionFiles

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 09-2017
!  Called from CRPOINT; write checkpoint data to fort.95/96
! =================================================================================================
subroutine scatter_crpoint(fileunit,writeerr,ierro)
    
      use crcoall
    implicit none
    integer, intent(in)    :: fileunit
    logical, intent(out)   :: writeerr
    integer, intent(inout) :: ierro    !Operate dummy in "passthrough" mode if no error -> inout

    integer j
    
    write(fileunit,err=1,iostat=ierro) &
          scatter_filepos, &
          scatter_seed1, scatter_seed2, &
          scatter_nidata, scatter_nfdata, scatter_ncdata, &
         (scatter_idata(j), j=1,scatter_maxdata), &
         (scatter_fdata(j), j=1,scatter_maxdata), &
         (scatter_cdata(j), j=1,scatter_maxdata)
    endfile   (fileunit,iostat=ierro)
    backspace (fileunit,iostat=ierro)
    
    return
    
1   continue
    writeerr=.true.
    
end subroutine scatter_crpoint

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 09-2017
!  Called from CRSTART; copies the _cr arrays into the normal arrays used during tracking in order
!  to recreate the state of the SCATTER block at the time of the checkpoint.
! =================================================================================================
subroutine scatter_crstart
    
    implicit none
    
    integer j
    
    scatter_nidata = scatter_nidata_cr
    scatter_nfdata = scatter_nfdata_cr
    scatter_ncdata = scatter_ncdata_cr
    
    do j=1, scatter_maxdata
        scatter_idata(j) = scatter_idata_cr(j)
        scatter_fdata(j) = scatter_fdata_cr(j)
        scatter_cdata(j) = scatter_cdata_cr(j)
    end do
    
end subroutine scatter_crstart
#endif
! End of CR

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 2018-04-20
! =================================================================================================
subroutine scatter_dumpData
  
  use crcoall
  
  implicit none
  
  integer ii

  write(lout,"(a)")             "*** BEGIN SCATTER DUMP ***"
  
  write(lout,"(a)")             "Options:"
  write(lout,"(a,l1)")          "scatter_active =", scatter_active
  write(lout,"(a,l1)")          "scatter_debug  =", scatter_debug
  write(lout,"(2(a,i8))")       "Seeds          =", scatter_seed1, ";", scatter_seed2
  
  write(lout,"(a)")             "Arrays:"
  
  write(lout,"(a,2(i3,a))")     "scatter_ELEM: (",scatter_nELEM,",",5,"):"
  write(lout,"(i4,a,5(1x,i3))") (ii,":",scatter_ELEM(ii,:),ii=1,scatter_nELEM)
  
  write(lout,"(a,i3,a)")        "scatter_ELEM_scale: (",scatter_nELEM,"):"
  write(lout,"(i4,a,e14.7)")    (ii,":",scatter_ELEM_scale(ii),ii=1,scatter_nELEM)
  
  write(lout,"(a,2(i3,a))")     "scatter_PROFILE: (", scatter_nPROFILE,",",5,"):"
  write(lout,"(i4,a,5(1x,i3))") (ii,":",scatter_PROFILE(ii,:),ii=1,scatter_nPROFILE)
  
  write(lout,"(a,2(i3,a))")     "scatter_GENERATOR: (",scatter_nGENERATOR,",",5,"):"
  write(lout,"(i4,a,5(1x,i3))") (ii,":",scatter_GENERATOR(ii,:),ii=1,scatter_nGENERATOR)
  
  write(lout,"(a,i3,a)")        "scatter_idata: (",scatter_nidata,"):"
  write(lout,"(i4,a,i4)")       (ii,":",scatter_idata(ii),ii=1,scatter_nidata)
  
  write(lout,"(a,i3,a)")        "scatter_fdata: (",scatter_nfdata,"):"
  write(lout,"(i4,a,e14.7)")    (ii,":",scatter_fdata(ii),ii=1,scatter_nfdata)
  
  write(lout,"(a,i3,a)")        "scatter_cdata: (",scatter_ncdata,"):"
  write(lout,"(i4,a)")          (ii,": '"//trim(chr_trimZero(scatter_cdata(ii)))//"'",ii=1,scatter_ncdata)
  
  write(lout,"(a)")             "**** END SCATTER DUMP ****"
  
end subroutine scatter_dumpData

! =================================================================================================
!  BEGIN Input Parser Functions
! =================================================================================================

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 2018-04-20
! =================================================================================================
subroutine scatter_parseInputLine(inLine)
  
  use strings
  use string_tools
  
  implicit none
  
  type(string), intent(in)  :: inLine
  type(string), allocatable :: lnSplit(:)
  integer nSplit
  
  ! Split the input line
  call str_split(inLine,lnSplit,nSplit)
  
  if(nSplit == 0) then
    if(scatter_debug) then
      write (lout,"(a,i3,a)") "SCATTER> DEBUG Input line len=",len(inLine%chr),": '",chr_trim(inLine%chr),"'."
      write (lout,"(a)")      "SCATTER> DEBUG  * No fields found."
    end if
    return
  end if
  
  select case(lnSplit(1)%chr)
  case("DEBUG")
    scatter_debug = .true.
    write(lout,"(a)") "SCATTER> Scatter block debugging is ON."
  case("ELEM")
    call scatter_parseElem(lnSplit, nSplit)
  case("PRO")
    call scatter_parseProfile(lnSplit, nSplit)
  case("GEN")
    call scatter_parseGenerator(lnSplit, nSplit)
  case("SEED")
    call scatter_parseSeed(lnSplit, nSplit)
  case default
    write(lout,"(a)")  "SCATTER> ERROR Line type not recognized:"
    write(lout,"(3a)") "SCATTER> '",lnSplit(1)%chr,"'"
    call prror(-1)
  end select
  
end subroutine scatter_parseInputLine

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 2018-04-20
! =================================================================================================
subroutine scatter_parseElem(lnSplit, nSplit)

  use crcoall
  use mod_common
  use mod_commonmn
  use strings
  use string_tools
  
  implicit none
  
  type(string), allocatable, intent(in) :: lnSplit(:)
  integer,                   intent(in) :: nSplit
  
  ! Temporary Variables
  integer ii, j
  
  ! Check number of arguments
  if(nSplit < 5) then
    write(lout,"(a)") "SCATTER> ERROR, ELEM expected at least 5 arguments:"
    write(lout,"(a)") "ELEM elemname profile scaling gen1 (gen2...)"
    call prror(-1)
  end if

  ! Add the element to the list
  scatter_nELEM = scatter_nELEM + 1
  call resize(scatter_ELEM, scatter_nELEM, 5, 0, "scatter_ELEM")
  call resize(scatter_ELEM_scale, scatter_nELEM, zero, "scatter_ELEM_scale")
  
  ! Find the single element referenced
  ii = -1
  do j=1,il
    if(bez(j) == lnSplit(2)%chr) then
      if(ii /= -1) then
        write(lout,"(3a)") "SCATTER> ERROR, found element '",lnSplit(2)%chr,"' twice in SINGLE ELEMENTS list."
        call prror(-1)
      end if
      ii = j
      
      if(scatter_elemPointer(j) /= 0) then
        write(lout,"(3a)") "SCATTER> ERROR, tried to define element '",lnSplit(2)%chr,"' twice."
        call prror(-1)
      end if
      
      if(kz(j) /= 40) then
        write(lout,"(3a,1x,i4)") "SCATTER> ERROR, SCATTER can only work on SINGLE ELEMENTs"//&
          "of type 40; the referenced element '",lnSplit(2)%chr,"'is of type", kz(j)
        call prror(-1)
      end if
      
      if(el(j) /= 0 .or. ek(j) /= 0 .or. ed(j) /= 0) then
        write(lout,*) "SCATTER> ERROR: length el(j) (SCATTER is treated as thin element), "// &
                      " and first and second field have to be zero: el(j)=ed(j)=ek(j)=0; "//&
                      "but el(",j,")=",el(j),", ed(",j,")=",ed(j),", ek(",j,")=",ek(j),"."
        write(lout,*) "Please check your input in the single element "//&
                      "definition of your SCATTER. All values except for the type must be zero."
        call prror(-1)
      end if
      
      scatter_elemPointer(j) = scatter_nELEM
      scatter_ELEM(scatter_nELEM,1) = j
    end if
  end do
  
  if(scatter_ELEM(scatter_nELEM,1) == 0) then
    write(lout,"(3a)") "SCATTER> ERROR: Could not find element '",lnSplit(2)%chr,"'"
    call prror(-1)
  end if
  
  ! Find the profile name referenced
  do j=1,scatter_nPROFILE
    if(trim(chr_trimZero(scatter_cdata(scatter_PROFILE(j,1)))) == lnSplit(3)%chr) then
      scatter_ELEM(scatter_nELEM,2) = j
    end if
  end do
  
  if (scatter_ELEM(scatter_nELEM,2) == 0) then
    write(lout,"(3a)") "SCATTER> ERROR: Could not find profile '",lnSplit(3)%chr,"'"
    call prror(-1)
  end if
  
  ! Store the scaling
  scatter_ELEM_scale(scatter_nELEM) = str_toReal(lnSplit(4))
  ! if(errno .ne. 0) call rounderr(errno,getfields_fields,4,scatter_ELEM_scale(scatter_nELEM))

  ! Find the generator(s) referenced
  if(nSplit-4 > 3) then
    write(lout,"(a,i2,a)") "SCATTER> ERROR when parsing ELEM,",nSplit-4,"generators specified, space for 3"
    call prror(-1)
  end if
  
  do ii=5,nSplit
    ! In general inside this loop:
    ! Take care of offsets in getfields_field (-4) and scatter_ELEM (+2)
    ! such that ii=5 -> column 3 of scatter_ELEM, ii=6 -> column 4, etc.
    !
    ! A dummy variable might not be a bad idea here ...

    !In case we won't find the generator name
    scatter_ELEM(scatter_nELEM,ii-4+2) = -1
    
    ! Search for the generator with the right name
    do j=1, scatter_nGENERATOR
      if(trim(chr_trimZero(scatter_cdata(scatter_GENERATOR(j,1)))) == lnSplit(ii)%chr) then
        ! Found it
        scatter_ELEM(scatter_nELEM,ii-4+2) = j
      end if
    end do
    
    ! If it is still -1, it wasn't found
    if(scatter_ELEM(scatter_nELEM,ii-4+2) == -1) then
      write(lout,"(3a)") "SCATTER> ERROR when parsing ELEM, generator '",lnSplit(ii)%chr,"' not found."
      call prror(-1)
    end if
    
    ! Loop over those GENerators we've filled before
    ! (i.e. up to but not including column ii-4+2)
    ! to check for duplicates
    do j=3, ii-4+2-1
      if(scatter_ELEM(scatter_nELEM,j) == scatter_ELEM(scatter_nELEM,ii-4+2)) then
        write(lout,"(3a)") "SCATTER> ERROR when parsing ELEM, generator '",lnSplit(ii)%chr,"' used twice."
        call prror(-1)
      end if
    end do
  end do
  
end subroutine scatter_parseElem

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 2018-04-20
! =================================================================================================
subroutine scatter_parseProfile(lnSplit, nSplit)
  
  use crcoall
  use strings
  use string_tools
  
  implicit none
  
  type(string), allocatable, intent(in) :: lnSplit(:)
  integer,                   intent(in) :: nSplit
  
  ! Temporary Variables
  integer ii, tmpIdx
  
  ! Check number of arguments
  if(nSplit < 3) then
    write(lout,"(a)") "SCATTER> ERROR, PRO expected at least 3 arguments:"
    write(lout,"(a)") "PRO name type (arguments...)"
    call prror(-1)
  end if
  
  ! Add a profile to the list
  scatter_nPROFILE = scatter_nPROFILE + 1
  call resize(scatter_PROFILE, scatter_nPROFILE, 5, 0, "scatter_PROFILE")
  
  ! Store the profile name
  scatter_ncdata = scatter_ncdata + 1
  if(scatter_ncdata > scatter_maxdata) then
    write(lout,"(a,i4,a)") "SCATTER> ERROR, scatter_maxdata = ",scatter_maxdata," exceeded for scatter_ncdata"
    call prror(-1)
  end if
  scatter_cdata(scatter_ncdata)       = lnSplit(2)%chr
  scatter_PROFILE(scatter_nPROFILE,1) = scatter_ncdata
  
  ! Check that the profile name is unique
  do ii=1,scatter_nPROFILE-1
    if(trim(chr_trimZero(scatter_cdata(scatter_PROFILE(ii,1)) )) == lnSplit(2)%chr) then
      write(lout,"(3a)") "SCATTER> ERROR, profile name '",lnSplit(2)%chr,"' is not unique."
      call prror(-1)
    end if
  end do
  
  ! Profile type dependent code
  select case (lnSplit(3)%chr)
  case("FLAT")
    scatter_PROFILE(scatter_nPROFILE,2) = 1 ! Integer code for FLAT
    if(nSplit /= 6) then
      write(lout,"(a)") "SCATTER> ERROR, PROfile type FLAT expected 6 arguments:"
      write(lout,"(a)") "PRO name FLAT density[targets/cm^2] mass[MeV/c^2] momentum[MeV/c]"
      call prror(-1)
    end if
    
    ! Request space to store the density
    tmpIdx = scatter_nfdata + 1
    scatter_PROFILE(scatter_nPROFILE,3) = tmpIdx
    scatter_nfdata = scatter_nfdata + 3
    if(scatter_nfdata > scatter_maxdata) then
      write(lout,"(a,i4,a)") "SCATTER> ERROR, maxdata = ",scatter_maxdata," exceeded for floats."
      call prror(-1)
    end if
    
    scatter_fdata(tmpIdx)   = str_toReal(lnSplit(4)) ! Density
    scatter_fdata(tmpIdx+1) = str_toReal(lnSplit(5)) ! Mass
    scatter_fdata(tmpIdx+2) = str_toReal(lnSplit(6)) ! Momentum
    
  case("GAUSS1")
    scatter_PROFILE(scatter_nPROFILE,2) = 10  ! Integer code for BEAM_GAUSS1
    if(nSplit /= 8) then
      write(lout,"(a)") "SCATTER> ERROR, PROfile type GAUSS1 expected 8 arguments:"
      write(lout,"(a)") "PRO name GAUSS1 beamtot[particles] sigma_x[mm] sigma_y[mm] offset_x[mm] offset_y[mm]"
      call prror(-1)
    end if
    
    ! Request space to store the density
    tmpIdx = scatter_nfdata + 1
    scatter_PROFILE(scatter_nPROFILE,3) = tmpIdx
    scatter_nfdata = scatter_nfdata + 5
    if(scatter_nfdata > scatter_maxdata) then
      write(lout,"(a,i4,a)") "SCATTER> ERROR, maxdata = ",scatter_maxdata," exceeded for floats."
      call prror(-1)
    end if
    
    scatter_fdata(tmpIdx)   = str_toReal(lnSplit(4)) ! Beam Charge
    scatter_fdata(tmpIdx+1) = str_toReal(lnSplit(5)) ! Sigma X
    scatter_fdata(tmpIdx+2) = str_toReal(lnSplit(6)) ! Sigma Y
    scatter_fdata(tmpIdx+3) = str_toReal(lnSplit(7)) ! Offset X
    scatter_fdata(tmpIdx+4) = str_toReal(lnSplit(8)) ! Offset Y
    
  case default
    write(lout,"(3a)") "SCATTER> ERROR, PRO name '",lnSplit(3)%chr,"' not recognized."
    call prror(-1)
    
  end select
  
end subroutine scatter_parseProfile

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 09-2017
! =================================================================================================
subroutine scatter_parseGenerator(lnSplit, nSplit)
  
  use crcoall
  use strings
  use string_tools
  
  implicit none
  
  type(string), allocatable, intent(in) :: lnSplit(:)
  integer,                   intent(in) :: nSplit
  
  ! Temporary Variables
  integer ii, tmpIdx
  
  ! Check number of arguments
  if(nSplit < 3) then
    write(lout,"(a)") "SCATTER> ERROR, GEN expected at least 3 arguments:"
    write(lout,"(a)") "GEN name type (arguments...)"
    call prror(-1)
  end if
  
  ! Add a generator to the list
  scatter_nGENERATOR = scatter_nGENERATOR + 1
  call resize(scatter_GENERATOR, scatter_nGENERATOR, 5, 0, "scatter_GENERATOR")
  
  ! Store the generator name
  scatter_ncdata = scatter_ncdata + 1
  if(scatter_ncdata .gt. scatter_maxdata) then
    write(lout,"(a,i4,a)") "SCATTER> ERROR, scatter_maxdata = ",scatter_maxdata," exceeded for scatter_ncdata"
    call prror(-1)
  end if
  scatter_cdata(scatter_ncdata)           = lnSplit(2)%chr
  scatter_GENERATOR(scatter_nGENERATOR,1) = scatter_ncdata
  
  ! Check that the generator name is unique
  do ii=1,scatter_nGENERATOR-1
    if(trim(chr_trimZero(scatter_cdata(scatter_GENERATOR(ii,1)))) == lnSplit(2)%chr) then
      write(lout,"(3a)") "SCATTER> ERROR, generator name '",lnSplit(2)%chr,"' is not unique."
      call prror(-1)
    end if
  end do
  
  ! Generator type-dependent code
  select case (lnSplit(3)%chr)
  case("ABSORBER")
    
    scatter_GENERATOR(scatter_nGENERATOR,2) = 1  ! Code for ABSORBER
    
  case("PPBEAMELASTIC")
    
    scatter_GENERATOR(scatter_nGENERATOR,2) = 10 ! Code for PPBEAMELASTIC
    if(nSplit < 8 .or. nSplit > 9) then
      write(lout,"(a)") "SCATTER> ERROR, GEN PPBEAMELASTIC expected 8 or 9 arguments:"
      write(lout,"(a)") "GEN name PPBEAMELASTIC a b1 b2 phi tmin (crossSection)"
      call prror(-1)
    end if
    
    ! Request space to store the arguments
    tmpIdx = scatter_nfdata + 1
    scatter_GENERATOR(scatter_nGENERATOR,3) = tmpIdx
    scatter_GENERATOR(scatter_nGENERATOR,4) = 0      ! Index of scatter input, if present
    scatter_nfdata = scatter_nfdata + nSplit - 3
    if(scatter_nfdata > scatter_maxdata) then
      write(lout,"(a,i4,a)") "SCATTER> ERROR, maxdata = ",scatter_maxdata," exceeded for floats."
      call prror(-1)
    end if

    scatter_fdata(tmpIdx)   = str_toReal(lnSplit(4)) ! PPBEAMELASTIC a
    scatter_fdata(tmpIdx+1) = str_toReal(lnSplit(5)) ! PPBEAMELASTIC b1
    scatter_fdata(tmpIdx+2) = str_toReal(lnSplit(6)) ! PPBEAMELASTIC b2
    scatter_fdata(tmpIdx+3) = str_toReal(lnSplit(7)) ! PPBEAMELASTIC phi
    scatter_fdata(tmpIdx+4) = str_toReal(lnSplit(8)) ! PPBEAMELASTIC tmin
    
    if(nSplit == 9) then
      scatter_fdata(tmpIdx+5) = str_toReal(lnSplit(9)) ! PPBEAMELASTIC crossSection
    end if
    
    ! Check sanity of input values
    if(scatter_fdata(tmpIdx+1) < pieni) then
      write(lout,"(a)") "SCATTER> ERROR, GEN PPBEAMELASTIC 5th input (b1) must be larger than zero"
      call prror(-1)
    end if
    if(scatter_fdata(tmpIdx+2) < pieni) then
      write(lout,"(a)") "SCATTER> ERROR, GEN PPBEAMELASTIC 6th input (b2) must be larger than zero"
      call prror(-1)
    end if
    
  case default
    
    write(lout,"(3a)") "SCATTER> ERROR, GEN name '",lnSplit(3)%chr,"' not recognized."
    call prror(-1)
    
  end select
    
end subroutine scatter_parseGenerator

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 09-2017
! =================================================================================================
subroutine scatter_parseSeed(lnSplit, nSplit)

  use crcoall
  use strings
  use string_tools
  
  implicit none
  
  type(string), allocatable, intent(in) :: lnSplit(:)
  integer,                   intent(in) :: nSplit

  ! Check the number of arguments
  if(nSplit /= 3) then
    write(lout,"(a)") "SCATTER> ERROR, SEED expected 2 arguments:"
    write(lout,"(a)") "GEN seed1 seed2"
    call prror(-1)
  end if

  ! Read the seeds
  read(lnSplit(2)%chr,*) scatter_seed1
  read(lnSplit(3)%chr,*) scatter_seed2

end subroutine scatter_parseSeed
! =================================================================================================
! END Input Parser Functions
! =================================================================================================

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 02-11-2017
! =================================================================================================
subroutine scatter_thin(i_elem, ix, turn)
  
  use string_tools
  use crcoall
  use mod_common
  use mod_commonmn
#ifdef HDF5
  use hdf5_output
#endif
  
  implicit none
  
+if collimat
+ca collpara ! Needed to define array sizes
+ca dbcommon ! Get the arrays that we need to set to mark the particle as "dirty" for collimation
+ei
  
  ! Temp variables
  integer          ELEMidx, PROidx, GENidx
  integer          i, j
  integer          tmpSeed1, tmpSeed2
  real(kind=fPrec) s, t, xi, theta
  real(kind=fPrec) crossSection, N, P
  real(kind=fPrec) rndPhi(npart), rndP(npart)
  real(kind=fPrec) scaling

  integer, intent(in) :: i_elem, ix, turn

  ELEMidx = scatter_elemPointer(ix)
  PROidx  = scatter_ELEM(ELEMidx,2)
  scaling = scatter_ELEM_scale(ELEMidx)

  if (scatter_debug) then
    write(lout,*) "SCATTER> In scatter_thin, ix=",ix, &
                  "bez='"//trim(bez(ix))//"' napx=",napx, "turn=",turn, &
                  "scaling=",scaling
  end if
  
  if (scaling.le.pieni) then
    ! Skip the whole thing if the scaling is zero
    return
  end if
    
  ! Store the seeds in the randum number generator, and set ours
  call recuut(tmpSeed1,tmpSeed2)
  call recuin(scatter_seed1,scatter_seed2)
  
  ! Loop over generators
  do i=3,5
    
    GENidx = scatter_ELEM(ELEMidx,i)
    if(GENidx .eq. 0) exit ! No generator
    
    ! Generate a random phi
    call ranecu(rndPhi, napx, -1)
    call ranecu(rndP,   napx, -1)
    rndPhi = rndPhi*(two*pi)

    do j=1, napx
      ! Compute the cross section at this s
      ! (in most cases roughly equal for all particles; use mean x,y,xp,yp,E)
      crossSection = scatter_generator_getCrossSection( &
        PROidx,GENidx, xv(1,j),xv(2,j),yv(1,j),yv(2,j),ejv(j) &
      )
      
      ! Ask profile for density at x,y
      N = scatter_profile_getDensity(PROidx,xv(1,j),xv(2,j))

      ! Compute probability P
      P = (N*crossSection)*scaling
            
      ! If RNG > P -> go to next particle, else scatter
      if(rndP(j) > P) cycle
      
      ! Ask generator for t and xi
      call scatter_generator_getTandXi(GENidx,t,xi)

      ! Use generator t and xi to update particle j;
      ! remember to update ALL the energy arrays
      theta   = c1e3*sqrt(t)/ejfv(j)                  ! Scale to mrad
      yv(1,j) = theta*cos_mb(rndPhi(j)) + yv(1,j)
      yv(2,j) = theta*sin_mb(rndPhi(j)) + yv(2,j)

      ! Output to file
#ifdef HDF5
      if(h5_useForSCAT) then
        ! Something
      else
#endif
        write(scatter_logFile,"(2(1x,I8),2(1x,A),2(1x,F13.3),3(1x,1PE16.9))") j, turn, bez(ix), &
            trim(chr_trimZero(scatter_cdata(scatter_GENERATOR(GENidx,1)))), &
            t, xi, theta, rndPhi(j), P
#ifdef HDF5
      end if
#endif
#ifdef CR
      scatter_filepos = scatter_filepos+1
#endif

+if collimat
      scatterhit(j) = 8
      part_hit_pos = i_elem
      part_hit_turn = turn
+ei
    end do ! END loop over particles (j)
  end do

#ifdef CR
  endfile(scatter_logFile,iostat=ierro)
  backspace(scatter_logFile,iostat=ierro)
#endif
    
  ! Restore seeds in random generator
  call recuut(scatter_seed1,scatter_seed2)
  call recuin(tmpSeed1,tmpSeed2)
    
end subroutine scatter_thin

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 02-11-2017
! =================================================================================================
real(kind=fPrec) function scatter_profile_getDensity(profileIdx, x, y) result(retval)
    
    use string_tools
    use crcoall
    use mod_common
    
    implicit none
    
    integer, intent(in) :: profileIdx
    real(kind=fPrec), intent(in) :: x, y
    
    real(kind=fPrec) beamtot, sigmaX, sigmaY, offsetX, offsetY
    integer tmpIdx
    
    tmpIdx = scatter_PROFILE(profileIdx,3)
    
    select case (scatter_PROFILE(profileIdx,2))
    case (1)  ! FLAT
        retval  = scatter_fdata(tmpIdx)
    case (10) ! GAUSS1
        beamtot = scatter_fdata(tmpIdx)
        sigmaX  = scatter_fdata(tmpIdx + 1)
        sigmaY  = scatter_fdata(tmpIdx + 2)
        offsetX = scatter_fdata(tmpIdx + 3)
        offsetY = scatter_fdata(tmpIdx + 4)
        retval  = beamtot/(two*(pi*(sigmaX*sigmaY)))    &
                * exp_mb(-half*((x-offsetX)/sigmaX)**2) &
                * exp_mb(-half*((y-offsetY)/sigmaY)**2)
    case default
        write(lout,*) "SCATTER> ERROR in scatter_profile_getDensity"
        write(lout,*) "Type", scatter_PROFILE(profileIdx,2), &
                      "for profile '"// trim(chr_trimZero( &
                      scatter_cdata(scatter_PROFILE(profileIdx,1)) &
                      ))//"' not understood."
        call prror(-1)
    end select
    
end function scatter_profile_getDensity

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 09-2017
! =================================================================================================
subroutine scatter_profile_getParticle(profileIdx, x, y, xp, yp, E)
    
    implicit none

 
    integer, intent(in) :: profileIdx
    real(kind=fPrec), intent(in)  :: x, y
    real(kind=fPrec), intent(out) :: xp, yp, E

    ! Return a particle to collide with
    ! Add dummy variables for now, which stops ifort from complaining
    xp = zero
    yp = zero
    E  = zero
    
end subroutine scatter_profile_getParticle

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 09-2017
! =================================================================================================
real(kind=fPrec) function scatter_generator_getCrossSection(profileIDX, generatorIDX, x,y, xp,yp, E)
    
    use string_tools
    use crcoall
    
    implicit none

    integer, intent(in) :: profileIDX, generatorIDX
    real(kind=fPrec), intent(in) :: x, y, xp, yp, E

    ! Temporary variables
    integer          tmpIdx
    real(kind=fPrec) xp_target, yp_target, E_target

    ! Calculate S
    call scatter_profile_getParticle(profileIDX, x,y, xp_target,yp_target,E_target)

    ! Calculate the cross section as function of S
    select case (scatter_GENERATOR(generatorIDX,2))
    case (1)  ! ABSORBER
        !...

    case (10) ! PPBEAMELASTIC
        tmpIdx = scatter_GENERATOR(generatorIDX,4)
        if(tmpIdx .eq. 0) then
            scatter_generator_getCrossSection = 30d-27
        else
            scatter_generator_getCrossSection = scatter_fdata(tmpIdx)
        end if

    case default
        write(lout,*) "SCATTER> ERROR in scatter_generator_getCrossSection"
        write(lout,*) "Type", scatter_PROFILE(profileIdx,2), &
                      "for profile '"// trim(chr_trimZero( &
                      scatter_cdata(scatter_PROFILE(profileIdx,1)) &
                      ))//"' not understood."
        call prror(-1)

    end select

end function scatter_generator_getCrossSection

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 02-11-2017
! =================================================================================================
subroutine scatter_generator_getTandXi(generatorIDX, t, xi)

    use crcoall
    
    implicit none

    integer, intent(in) :: generatorIDX
    real(kind=fPrec), intent(out) :: t, xi

    ! Temporary variables
    integer          tmpIdx
    real(kind=fPrec) a, b1, b2, phi, tmin

    ! Could be affected by S as well?

    select case (scatter_GENERATOR(generatorIDX,2))
    case (1)  ! ABSORBER
        !...
    case (10) ! PPBEAMELASTIC

        tmpIdx = scatter_GENERATOR(generatorIDX,3)
        a      = scatter_fdata(tmpIdx)
        b1     = scatter_fdata(tmpIdx+1)
        b2     = scatter_fdata(tmpIdx+2)
        phi    = scatter_fdata(tmpIdx+3)
        tmin   = scatter_fdata(tmpIdx+4)
        
        t  = scatter_generator_getPPElastic(a, b1, b2, phi, tmin)
        xi = zero   ! Dummy value, for now
        t  = t*c1e6 ! Scale return variable to MeV^2

    case default
        write(lout,*) "SCATTER> ERROR in scatter_generator_getTandXi"
        write(lout,*) "Type", generatorIDX, "not understood"
        call prror(-1)

    end select

end subroutine scatter_generator_getTandXi

! =================================================================================================
!  K. Sjobak, V.K. Berglyd Olsen, BE-ABP-HSS
!  Last modified: 02-11-2017
!  Based on Helmut Burkhardt's code presented on 05-04-2017
!  "Elastic pp scattering estimates and simulation relevant for burn-off"
!  https://indico.cern.ch/event/625576/
! =================================================================================================
real(kind=fPrec) function scatter_generator_getPPElastic(a, b1, b2, phi, tmin) result(t)

    use crcoall
    
    implicit none

    real(kind=fPrec), intent(in) :: a, b1, b2, phi, tmin

    ! Temp Variables
    integer          nItt, maxItt
    real(kind=fPrec) g1, g2, g3, gg, prob3, invB1, invB2, rndArr(3)

    ! Approximate distribution
    g1    =           exp_mb(-b1*tmin)/b1  ! Soft scatter term
    g3    = (a**2) * (exp_mb(-b2*tmin)/b2) ! Hard scatter term
    prob3 = g3/(g1+g3)              ! Probability of g3
    
    ! Pre-calculate inverses
    invB1 = one/b1
    invB2 = one/b2

    nItt   = 0
    maxItt = 1000000
    do
        nItt = nItt + 1
        call ranecu(rndArr, 3, -1)

        ! Randomly switch between g1 and g3 according to probability
        if(rndArr(1) .gt. prob3) then
            t = tmin - invB1*log_mb(rndArr(2))
        else
            t = tmin - invB2*log_mb(rndArr(2))
        end if
        
        ! Exact distribution
        g1 =             exp_mb(-b1*t)                              ! Soft scatter term
        g2 =  ((two*a) * exp_mb(((-half)*(b1+b2))*t)) * cos_mb(phi) ! Interference
        g3 =    (a**2) * exp_mb(-b2*t)                              ! Hard scatter term
        gg = ((g1+g2)+g3)/(g1+g3)
        
        ! Check hit/miss on exact distribution
        ! if miss, get new t value
        ! if too many attempts, exit
        if(rndArr(3) .lt. gg .or. nItt .gt. maxItt) exit
    end do

    if(nItt .gt. maxItt) then
        write(lout,*) "SCATTER> ERROR in generator PPBEAMELASTIC"
        write(lout,*) "Limit of", maxItt, "misses in generator loop reached."
        call prror(-1)
    end if

end function scatter_generator_getPPElastic

end module scatter
